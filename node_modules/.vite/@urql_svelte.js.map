{
  "version": 3,
  "sources": ["../wonka/dist/wonka.mjs", "../@urql/core/src/utils/error.ts", "../@urql/core/src/utils/hash.ts", "../@urql/core/src/utils/stringifyVariables.ts", "../@urql/core/src/utils/request.ts", "../@urql/core/src/utils/result.ts", "../@urql/core/src/internal/fetchOptions.ts", "../@urql/core/src/internal/fetchSource.ts", "../@urql/core/src/utils/typenames.ts", "../@urql/core/src/utils/maskTypename.ts", "../@urql/core/src/utils/streamUtils.ts", "../@urql/core/src/utils/operation.ts", "../@urql/core/src/gql.ts", "../@urql/core/src/exchanges/cache.ts", "../@urql/core/src/exchanges/ssr.ts", "../@urql/core/src/exchanges/subscription.ts", "../@urql/core/src/exchanges/dedup.ts", "../@urql/core/src/exchanges/fetch.ts", "../@urql/core/src/exchanges/fallback.ts", "../@urql/core/src/exchanges/compose.ts", "../@urql/core/src/exchanges/error.ts", "../@urql/core/src/client.ts", "../@urql/svelte/src/internal.ts", "../@urql/svelte/src/operationStore.ts", "../@urql/svelte/src/context.ts", "../@urql/svelte/src/operations.ts"],
  "sourcesContent": ["function l(a, b) {\n  b.tag = a;\n  return b;\n}\n\nfunction m() {}\n\nfunction p(a) {\n  return function (b) {\n    var c = a.length;\n    let d = !1,\n      e = !1,\n      f = !1,\n      g = 0;\n    b(\n      l(0, [\n        function (h) {\n          if (h) {\n            d = !0;\n          } else if (e) {\n            f = !0;\n          } else {\n            for (e = f = !0; f && !d; ) {\n              g < c ? ((h = a[g]), (g = (g + 1) | 0), (f = !1), b(l(1, [h]))) : ((d = !0), b(0));\n            }\n            e = !1;\n          }\n        },\n      ])\n    );\n  };\n}\n\nfunction r() {}\n\nfunction t(a) {\n  a(0);\n}\n\nfunction u(a) {\n  let b = !1;\n  a(\n    l(0, [\n      function (c) {\n        c ? (b = !0) : b || a(0);\n      },\n    ])\n  );\n}\n\nfunction w(a) {\n  if (void 0 === a) {\n    return ((a = [v, 0]).tag = 256), a;\n  }\n  if (null === a || a[0] !== v) {\n    return a;\n  }\n  (a = [v, (a[1] + 1) | 0]).tag = 256;\n  return a;\n}\n\nfunction x(a) {\n  if (null === a || a[0] !== v) {\n    return a;\n  }\n  if (0 !== (a = a[1])) {\n    return [v, (a - 1) | 0];\n  }\n}\n\nfunction z(a) {\n  return function (b) {\n    return function (c) {\n      function d(b) {\n        'number' == typeof b\n          ? k &&\n            ((k = !1),\n            void 0 !== (b = e.shift())\n              ? ((b = a(x(b))), (k = !0), b(d))\n              : q\n              ? c(0)\n              : g || ((g = !0), f(0)))\n          : b.tag\n          ? k && (c(b), n ? (n = !1) : h(0))\n          : ((h = b = b[0]), (n = !1), b(0));\n      }\n      let e = [],\n        f = m,\n        g = !1,\n        h = m,\n        k = !1,\n        n = !1,\n        q = !1;\n      b(function (b) {\n        'number' == typeof b\n          ? q || ((q = !0), k || 0 !== e.length || c(0))\n          : b.tag\n          ? q || ((b = b[0]), (g = !1), k ? e.push(b) : ((b = a(b)), (k = !0), b(d)))\n          : (f = b[0]);\n      });\n      c(\n        l(0, [\n          function (c) {\n            if (c) {\n              if ((q || ((q = !0), f(1)), k)) {\n                return (k = !1), h(1);\n              }\n            } else {\n              q || g || ((g = !0), f(0)), k && !n && ((n = !0), h(0));\n            }\n          },\n        ])\n      );\n    };\n  };\n}\n\nfunction A(a) {\n  return a;\n}\n\nfunction B(a) {\n  return a;\n}\n\nfunction C(a) {\n  return a(0);\n}\n\nfunction D(a) {\n  return function (b) {\n    return function (c) {\n      let e = m,\n        f = !1,\n        g = [],\n        h = !1;\n      b(function (b) {\n        'number' == typeof b\n          ? h || ((h = !0), 0 === g.length && c(0))\n          : b.tag\n          ? h ||\n            ((f = !1),\n            (function (a) {\n              function b(a) {\n                'number' == typeof a\n                  ? 0 !== g.length &&\n                    ((g = g.filter(d)),\n                    (a = 0 === g.length),\n                    h && a ? c(0) : !f && a && ((f = !0), e(0)))\n                  : a.tag\n                  ? 0 !== g.length && (c(l(1, [a[0]])), k(0))\n                  : ((k = a = a[0]), (g = g.concat(a)), a(0));\n              }\n              function d(a) {\n                return a !== k;\n              }\n              let k = m;\n              1 === a.length ? a(b) : a.bind(null, b);\n            })(a(b[0])),\n            f || ((f = !0), e(0)))\n          : (e = b[0]);\n      });\n      c(\n        l(0, [\n          function (a) {\n            a\n              ? (h || ((h = !0), e(a)),\n                g.forEach(function (c) {\n                  return c(a);\n                }),\n                (g = []))\n              : (f || h ? (f = !1) : ((f = !0), e(0)), g.forEach(C));\n          },\n        ])\n      );\n    };\n  };\n}\n\nfunction E(a) {\n  return a;\n}\n\nfunction F(a) {\n  return a;\n}\n\nfunction G(a) {\n  return D(F)(a);\n}\n\nfunction H(a) {\n  return function (b) {\n    return function (c) {\n      let d = !1;\n      return b(function (e) {\n        if ('number' == typeof e) {\n          d || ((d = !0), c(e));\n        } else if (e.tag) {\n          d || (a(e[0]), c(e));\n        } else {\n          var g = e[0];\n          c(\n            l(0, [\n              function (a) {\n                if (!d) {\n                  return a && (d = !0), g(a);\n                }\n              },\n            ])\n          );\n        }\n      });\n    };\n  };\n}\n\nfunction J(a) {\n  a(0);\n}\n\nfunction K(a) {\n  return function (b) {\n    return function (c) {\n      function d(a) {\n        h &&\n          ('number' == typeof a\n            ? ((h = !1), n ? c(a) : f || ((f = !0), e(0)))\n            : a.tag\n            ? (c(a), k ? (k = !1) : g(0))\n            : ((g = a = a[0]), (k = !1), a(0)));\n      }\n      let e = m,\n        f = !1,\n        g = m,\n        h = !1,\n        k = !1,\n        n = !1;\n      b(function (b) {\n        'number' == typeof b\n          ? n || ((n = !0), h || c(0))\n          : b.tag\n          ? n ||\n            (h && (g(1), (g = m)), f ? (f = !1) : ((f = !0), e(0)), (b = a(b[0])), (h = !0), b(d))\n          : (e = b[0]);\n      });\n      c(\n        l(0, [\n          function (a) {\n            if (a) {\n              if ((n || ((n = !0), e(1)), h)) {\n                return (h = !1), g(1);\n              }\n            } else {\n              n || f || ((f = !0), e(0)), h && !k && ((k = !0), g(0));\n            }\n          },\n        ])\n      );\n    };\n  };\n}\n\nfunction L(a) {\n  return a;\n}\n\nfunction M(a) {\n  return function (b) {\n    return function (c) {\n      let d = [],\n        e = m;\n      return b(function (b) {\n        'number' == typeof b\n          ? p(d)(c)\n          : b.tag\n          ? (d.length >= a && 0 < a && d.shift(), d.push(b[0]), e(0))\n          : ((b = b[0]), 0 >= a ? (b(1), u(c)) : ((e = b), b(0)));\n      });\n    };\n  };\n}\n\nfunction N(a) {\n  return function (b) {\n    let c = m,\n      d = !1;\n    b(function (e) {\n      'number' == typeof e ? (d = !0) : e.tag ? d || (a(e[0]), c(0)) : ((c = e = e[0]), e(0));\n    });\n    return {\n      unsubscribe: function () {\n        if (!d) {\n          return (d = !0), c(1);\n        }\n      },\n    };\n  };\n}\n\nfunction O() {}\n\nfunction Q() {}\n\nfunction R() {}\n\nfunction S() {}\n\nfunction buffer$1(a) {\n  return function (b) {\n    return function (c) {\n      function d(a) {\n        'number' == typeof a\n          ? k || ((k = !0), f(1), 0 < e.length && c(l(1, [e])), c(0))\n          : a.tag\n          ? !k && 0 < e.length && ((a = e), (e = []), c(l(1, [a])))\n          : (g = a[0]);\n      }\n      let e = [],\n        f = m,\n        g = m,\n        h = !1,\n        k = !1;\n      b(function (b) {\n        'number' == typeof b\n          ? k || ((k = !0), g(1), 0 < e.length && c(l(1, [e])), c(0))\n          : b.tag\n          ? k || (e.push(b[0]), h ? (h = !1) : ((h = !0), f(0), g(0)))\n          : ((f = b[0]), a(d));\n      });\n      c(\n        l(0, [\n          function (a) {\n            if (!k) {\n              if (a) {\n                return (k = !0), f(1), g(1);\n              }\n              if (!h) {\n                return (h = !0), f(0), g(0);\n              }\n            }\n          },\n        ])\n      );\n    };\n  };\n}\n\nfunction combine$1(a, b) {\n  return (function (a, b) {\n    return function (c) {\n      let d = m,\n        e = m,\n        f = void 0,\n        g = void 0,\n        h = !1,\n        k = 0,\n        n = !1;\n      a(function (a) {\n        var b = g;\n        'number' == typeof a\n          ? 1 > k\n            ? (k = (k + 1) | 0)\n            : n || ((n = !0), c(0))\n          : a.tag\n          ? ((a = a[0]),\n            void 0 !== b\n              ? n || ((f = w(a)), (h = !1), c(l(1, [[a, x(b)]])))\n              : ((f = w(a)), h ? (h = !1) : e(0)))\n          : (d = a[0]);\n      });\n      b(function (a) {\n        var b = f;\n        'number' == typeof a\n          ? 1 > k\n            ? (k = (k + 1) | 0)\n            : n || ((n = !0), c(0))\n          : a.tag\n          ? ((a = a[0]),\n            void 0 !== b\n              ? n || ((g = w(a)), (h = !1), c(l(1, [[x(b), a]])))\n              : ((g = w(a)), h ? (h = !1) : d(0)))\n          : (e = a[0]);\n      });\n      c(\n        l(0, [\n          function (c) {\n            if (!n) {\n              if (c) {\n                return (n = !0), d(1), e(1);\n              }\n              if (!h) {\n                return (h = !0), d(c), e(c);\n              }\n            }\n          },\n        ])\n      );\n    };\n  })(a, b);\n}\n\nfunction concat$1(a) {\n  return z(B)(p(a));\n}\n\nfunction concatAll$1(a) {\n  return z(A)(a);\n}\n\nfunction debounce$1(a) {\n  return function (b) {\n    return function (c) {\n      function d() {\n        var a = e;\n        void 0 !== a && ((e = void 0), clearTimeout(x(a)));\n      }\n      let e = void 0,\n        f = !1,\n        g = !1;\n      return b(function (b) {\n        if ('number' == typeof b) {\n          g || ((g = !0), void 0 !== e ? (f = !0) : c(0));\n        } else if (b.tag) {\n          g ||\n            (d(),\n            (e = w(\n              setTimeout(function () {\n                e = void 0;\n                c(b);\n                f && c(0);\n              }, a(b[0]))\n            )));\n        } else {\n          var n = b[0];\n          c(\n            l(0, [\n              function (a) {\n                if (!g) {\n                  return a ? ((g = !0), (f = !1), d(), n(1)) : n(0);\n                }\n              },\n            ])\n          );\n        }\n      });\n    };\n  };\n}\n\nfunction delay$1(a) {\n  return function (b) {\n    return function (c) {\n      let d = 0;\n      return b(function (b) {\n        'number' == typeof b || b.tag\n          ? ((d = (d + 1) | 0),\n            setTimeout(function () {\n              0 !== d && ((d = (d - 1) | 0), c(b));\n            }, a))\n          : c(b);\n      });\n    };\n  };\n}\n\nfunction filter$1(a) {\n  return function (b) {\n    return function (c) {\n      let d = m;\n      return b(function (b) {\n        'number' == typeof b ? c(b) : b.tag ? (a(b[0]) ? c(b) : d(0)) : ((d = b[0]), c(b));\n      });\n    };\n  };\n}\n\nfunction forEach$1(a) {\n  return function (b) {\n    N(a)(b);\n  };\n}\n\nfunction fromCallbag$2(a) {\n  return function (b) {\n    function c(a, c) {\n      switch (a) {\n        case 0:\n          b(\n            l(0, [\n              function (a) {\n                return a ? c(2) : c(1);\n              },\n            ])\n          );\n          break;\n\n        case 1:\n          b(l(1, [c]));\n          break;\n\n        case 2:\n          b(0);\n      }\n    }\n    return 2 === a.length ? a(0, c) : a.bind(null, 0, c);\n  };\n}\n\nfunction fromDomEvent$1(a, b) {\n  return (function (a, b) {\n    return function (c) {\n      function d(a) {\n        c(l(1, [a]));\n      }\n      c(\n        l(0, [\n          function (c) {\n            c && a.removeEventListener(b, d);\n          },\n        ])\n      );\n      a.addEventListener(b, d);\n    };\n  })(a, b);\n}\n\nfunction fromList$1(a) {\n  return function (b) {\n    let c = !1,\n      d = !1,\n      e = !1,\n      f = a;\n    b(\n      l(0, [\n        function (a) {\n          if (a) {\n            c = !0;\n          } else if (d) {\n            e = !0;\n          } else {\n            for (d = e = !0; e && !c; ) {\n              (a = f) ? ((f = a[1]), (e = !1), b(l(1, [a[0]]))) : ((c = !0), b(0));\n            }\n            d = !1;\n          }\n        },\n      ])\n    );\n  };\n}\n\nfunction fromObservable$2(a) {\n  var b = void 0 !== a[P] ? a[P]() : a;\n  return function (a) {\n    var c = b.subscribe({\n      next: function (c) {\n        a(l(1, [c]));\n      },\n      complete: function () {\n        a(0);\n      },\n      error: Q,\n    });\n    a(\n      l(0, [\n        function (a) {\n          if (a) {\n            return c.unsubscribe();\n          }\n        },\n      ])\n    );\n  };\n}\n\nfunction fromPromise$1(a) {\n  return function (b) {\n    let c = !1;\n    a.then(function (a) {\n      c || (b(l(1, [a])), b(0));\n      return Promise.resolve(void 0);\n    });\n    b(\n      l(0, [\n        function (a) {\n          a && (c = !0);\n        },\n      ])\n    );\n  };\n}\n\nfunction fromValue$1(a) {\n  return function (b) {\n    let c = !1;\n    b(\n      l(0, [\n        function (d) {\n          d ? (c = !0) : c || ((c = !0), b(l(1, [a])), b(0));\n        },\n      ])\n    );\n  };\n}\n\nfunction interval$1(a) {\n  return function (b) {\n    let c = 0;\n    var d = setInterval(function () {\n      var a = c;\n      c = (c + 1) | 0;\n      b(l(1, [a]));\n    }, a);\n    b(\n      l(0, [\n        function (a) {\n          a && clearInterval(d);\n        },\n      ])\n    );\n  };\n}\n\nfunction make$1(a) {\n  return function (b) {\n    let c = r,\n      d = !1;\n    c = a({\n      next: function (a) {\n        d || b(l(1, [a]));\n      },\n      complete: function () {\n        d || ((d = !0), b(0));\n      },\n    });\n    b(\n      l(0, [\n        function (a) {\n          if (a && !d) {\n            return (d = !0), c();\n          }\n        },\n      ])\n    );\n  };\n}\n\nfunction makeSubject$1() {\n  let a = [],\n    b = !1;\n  return {\n    source: function (c) {\n      function b(a) {\n        return a !== c;\n      }\n      a = a.concat(c);\n      c(\n        l(0, [\n          function (c) {\n            c && (a = a.filter(b));\n          },\n        ])\n      );\n    },\n    next: function (c) {\n      b ||\n        a.forEach(function (a) {\n          a(l(1, [c]));\n        });\n    },\n    complete: function () {\n      b || ((b = !0), a.forEach(t));\n    },\n  };\n}\n\nfunction map$1(a) {\n  return function (b) {\n    return function (c) {\n      return b(function (b) {\n        b = 'number' == typeof b ? 0 : b.tag ? l(1, [a(b[0])]) : l(0, [b[0]]);\n        c(b);\n      });\n    };\n  };\n}\n\nfunction merge$1(a) {\n  return D(E)(p(a));\n}\n\nfunction never$1(a) {\n  a(l(0, [m]));\n}\n\nfunction onEnd$1(a) {\n  return function (b) {\n    return function (c) {\n      let d = !1;\n      return b(function (b) {\n        if ('number' == typeof b) {\n          if (d) {\n            return;\n          }\n          d = !0;\n          c(b);\n          return a();\n        }\n        if (b.tag) {\n          d || c(b);\n        } else {\n          var e = b[0];\n          c(\n            l(0, [\n              function (c) {\n                if (!d) {\n                  return c ? ((d = !0), e(c), a()) : e(c);\n                }\n              },\n            ])\n          );\n        }\n      });\n    };\n  };\n}\n\nfunction onStart$1(a) {\n  return function (b) {\n    return function (c) {\n      return b(function (b) {\n        'number' == typeof b ? c(b) : b.tag ? c(b) : (c(b), a());\n      });\n    };\n  };\n}\n\nfunction pipe() {\n  for (var a = arguments, b = arguments[0], c = 1, d = arguments.length; c < d; c++) {\n    b = a[c](b);\n  }\n  return b;\n}\n\nfunction publish$1(a) {\n  return N(O)(a);\n}\n\nfunction sample$1(a) {\n  return function (b) {\n    return function (c) {\n      let d = m,\n        e = m,\n        f = void 0,\n        g = !1,\n        h = !1;\n      b(function (a) {\n        'number' == typeof a\n          ? h || ((h = !0), e(1), c(0))\n          : a.tag\n          ? ((f = w(a[0])), g ? (g = !1) : ((g = !0), e(0), d(0)))\n          : (d = a[0]);\n      });\n      a(function (a) {\n        var b = f;\n        'number' == typeof a\n          ? h || ((h = !0), d(1), c(0))\n          : a.tag\n          ? void 0 === b || h || ((f = void 0), c(l(1, [x(b)])))\n          : (e = a[0]);\n      });\n      c(\n        l(0, [\n          function (a) {\n            if (!h) {\n              if (a) {\n                return (h = !0), d(1), e(1);\n              }\n              if (!g) {\n                return (g = !0), d(0), e(0);\n              }\n            }\n          },\n        ])\n      );\n    };\n  };\n}\n\nfunction scan$1(a, b) {\n  return (function (a, b) {\n    return function (c) {\n      return function (d) {\n        let e = b;\n        return c(function (c) {\n          'number' == typeof c\n            ? (c = 0)\n            : c.tag\n            ? ((e = a(e, c[0])), (c = l(1, [e])))\n            : (c = l(0, [c[0]]));\n          d(c);\n        });\n      };\n    };\n  })(a, b);\n}\n\nfunction share$1(a) {\n  function b(a) {\n    'number' == typeof a\n      ? (c.forEach(J), (c = []))\n      : a.tag\n      ? ((e = !1),\n        c.forEach(function (b) {\n          b(a);\n        }))\n      : (d = a[0]);\n  }\n  let c = [],\n    d = m,\n    e = !1;\n  return function (f) {\n    function g(a) {\n      return a !== f;\n    }\n    c = c.concat(f);\n    1 === c.length && a(b);\n    f(\n      l(0, [\n        function (a) {\n          if (a) {\n            if (((c = c.filter(g)), 0 === c.length)) {\n              return d(1);\n            }\n          } else {\n            e || ((e = !0), d(a));\n          }\n        },\n      ])\n    );\n  };\n}\n\nfunction skip$1(a) {\n  return function (b) {\n    return function (c) {\n      let d = m,\n        e = a;\n      return b(function (a) {\n        'number' == typeof a\n          ? c(a)\n          : a.tag\n          ? 0 < e\n            ? ((e = (e - 1) | 0), d(0))\n            : c(a)\n          : ((d = a[0]), c(a));\n      });\n    };\n  };\n}\n\nfunction skipUntil$1(a) {\n  return function (b) {\n    return function (c) {\n      function d(a) {\n        'number' == typeof a\n          ? g && ((k = !0), e(1))\n          : a.tag\n          ? ((g = !1), f(1))\n          : ((f = a = a[0]), a(0));\n      }\n      let e = m,\n        f = m,\n        g = !0,\n        h = !1,\n        k = !1;\n      b(function (b) {\n        'number' == typeof b\n          ? (g && f(1), (k = !0), c(0))\n          : b.tag\n          ? g || k\n            ? h\n              ? (h = !1)\n              : ((h = !0), e(0), f(0))\n            : ((h = !1), c(b))\n          : ((e = b[0]), a(d));\n      });\n      c(\n        l(0, [\n          function (a) {\n            if (!k) {\n              if (a) {\n                if (((k = !0), e(1), g)) {\n                  return f(1);\n                }\n              } else {\n                h || ((h = !0), g && f(0), e(0));\n              }\n            }\n          },\n        ])\n      );\n    };\n  };\n}\n\nfunction skipWhile$1(a) {\n  return function (b) {\n    return function (c) {\n      let d = m,\n        e = !0;\n      return b(function (b) {\n        'number' == typeof b\n          ? c(b)\n          : b.tag\n          ? e\n            ? a(b[0])\n              ? d(0)\n              : ((e = !1), c(b))\n            : c(b)\n          : ((d = b[0]), c(b));\n      });\n    };\n  };\n}\n\nfunction switchAll$1(a) {\n  return K(L)(a);\n}\n\nfunction take$1(a) {\n  return function (b) {\n    return function (c) {\n      let d = !1,\n        e = 0,\n        f = m;\n      b(function (b) {\n        'number' == typeof b\n          ? d || ((d = !0), c(0))\n          : b.tag\n          ? e < a && !d && ((e = (e + 1) | 0), c(b), !d && e >= a && ((d = !0), c(0), f(1)))\n          : ((b = b[0]), 0 >= a ? ((d = !0), c(0), b(1)) : (f = b));\n      });\n      c(\n        l(0, [\n          function (b) {\n            if (!d) {\n              if (b) {\n                return (d = !0), f(1);\n              }\n              if (e < a) {\n                return f(0);\n              }\n            }\n          },\n        ])\n      );\n    };\n  };\n}\n\nfunction takeUntil$1(a) {\n  return function (b) {\n    return function (c) {\n      function d(a) {\n        'number' != typeof a && (a.tag ? ((e = !0), f(1), c(0)) : ((g = a = a[0]), a(0)));\n      }\n      let e = !1,\n        f = m,\n        g = m;\n      b(function (b) {\n        'number' == typeof b ? e || ((e = !0), g(1), c(0)) : b.tag ? e || c(b) : ((f = b[0]), a(d));\n      });\n      c(\n        l(0, [\n          function (a) {\n            if (!e) {\n              return a ? ((e = !0), f(1), g(1)) : f(0);\n            }\n          },\n        ])\n      );\n    };\n  };\n}\n\nfunction takeWhile$1(a) {\n  return function (b) {\n    return function (c) {\n      let d = m,\n        e = !1;\n      return b(function (b) {\n        'number' == typeof b\n          ? e || ((e = !0), c(0))\n          : b.tag\n          ? e || (a(b[0]) ? c(b) : ((e = !0), c(0), d(1)))\n          : ((d = b[0]), c(b));\n      });\n    };\n  };\n}\n\nfunction throttle$1(a) {\n  return function (b) {\n    return function (c) {\n      function d() {\n        void 0 !== g && clearTimeout(x(g));\n      }\n      function e() {\n        g = void 0;\n        f = !1;\n      }\n      let f = !1,\n        g = void 0;\n      return b(function (b) {\n        if ('number' == typeof b) {\n          d(), c(0);\n        } else if (b.tag) {\n          f || ((f = !0), d(), (g = w(setTimeout(e, a(b[0])))), c(b));\n        } else {\n          var h = b[0];\n          c(\n            l(0, [\n              function (a) {\n                return a ? (d(), h(1)) : h(a);\n              },\n            ])\n          );\n        }\n      });\n    };\n  };\n}\n\nfunction toArray$1(a) {\n  let b = [],\n    c = m,\n    d = !1;\n  a(function (a) {\n    'number' == typeof a ? (d = !0) : a.tag ? (b.push(a[0]), c(0)) : ((c = a = a[0]), a(0));\n  });\n  d || c(1);\n  return b;\n}\n\nfunction toCallbag$2(a) {\n  return function (b, c) {\n    if (0 === b) {\n      return a(function (a) {\n        function b(a) {\n          switch (a) {\n            case 1:\n              d(0);\n              break;\n\n            case 2:\n              d(1);\n          }\n        }\n        if ('number' == typeof a) {\n          return 2 === c.length ? c(2, void 0) : c.bind(null, 2, void 0);\n        }\n        if (a.tag) {\n          return (a = a[0]), 2 === c.length ? c(1, a) : c.bind(null, 1, a);\n        }\n        var d = a[0];\n        return 2 === c.length ? c(0, b) : c.bind(null, 0, b);\n      });\n    }\n  };\n}\n\nfunction toObservable$2(a) {\n  var b = {\n    subscribe: function (b, d, e) {\n      var c = ('object' == typeof b ? b.next.bind(b) : b) || R,\n        g = ('object' == typeof b ? b.complete.bind(b) : e) || S;\n      let h = m,\n        k = !1;\n      a(function (a) {\n        if ('number' == typeof a) {\n          return (k = !0), g();\n        }\n        if (a.tag) {\n          if (k) {\n            return;\n          }\n          c(a[0]);\n          return h(0);\n        }\n        h = a = a[0];\n        a(0);\n      });\n      return {\n        unsubscribe: function () {\n          if (!k) {\n            return (this.closed = !1), (k = !0), h(1);\n          }\n        },\n        closed: !1,\n      };\n    },\n  };\n  b[P] = function () {\n    return b;\n  };\n  return b;\n}\n\nfunction toPromise$1(a) {\n  return new Promise(function (b) {\n    M(1)(a)(function (a) {\n      if ('number' != typeof a) {\n        if (a.tag) {\n          b(a[0]);\n        } else {\n          a[0](0);\n        }\n      }\n    });\n  });\n}\n\nvar v = [],\n  P =\n    'function' == typeof Symbol\n      ? Symbol.observable || (Symbol.observable = Symbol('observable'))\n      : '@@observable';\n\nexport {\n  buffer$1 as buffer,\n  combine$1 as combine,\n  concat$1 as concat,\n  concatAll$1 as concatAll,\n  z as concatMap,\n  debounce$1 as debounce,\n  delay$1 as delay,\n  u as empty,\n  filter$1 as filter,\n  G as flatten,\n  forEach$1 as forEach,\n  p as fromArray,\n  fromCallbag$2 as fromCallbag,\n  fromDomEvent$1 as fromDomEvent,\n  fromList$1 as fromList,\n  fromObservable$2 as fromObservable,\n  fromPromise$1 as fromPromise,\n  fromValue$1 as fromValue,\n  interval$1 as interval,\n  make$1 as make,\n  makeSubject$1 as makeSubject,\n  map$1 as map,\n  merge$1 as merge,\n  G as mergeAll,\n  D as mergeMap,\n  never$1 as never,\n  onEnd$1 as onEnd,\n  H as onPush,\n  onStart$1 as onStart,\n  pipe,\n  publish$1 as publish,\n  sample$1 as sample,\n  scan$1 as scan,\n  share$1 as share,\n  skip$1 as skip,\n  skipUntil$1 as skipUntil,\n  skipWhile$1 as skipWhile,\n  N as subscribe,\n  switchAll$1 as switchAll,\n  K as switchMap,\n  take$1 as take,\n  M as takeLast,\n  takeUntil$1 as takeUntil,\n  takeWhile$1 as takeWhile,\n  H as tap,\n  throttle$1 as throttle,\n  toArray$1 as toArray,\n  toCallbag$2 as toCallbag,\n  toObservable$2 as toObservable,\n  toPromise$1 as toPromise,\n};\n", "import { GraphQLError } from 'graphql';\n\nconst generateErrorMessage = (\n  networkErr?: Error,\n  graphQlErrs?: GraphQLError[]\n) => {\n  let error = '';\n  if (networkErr !== undefined) {\n    return (error = `[Network] ${networkErr.message}`);\n  }\n\n  if (graphQlErrs !== undefined) {\n    graphQlErrs.forEach(err => {\n      error += `[GraphQL] ${err.message}\\n`;\n    });\n  }\n\n  return error.trim();\n};\n\nconst rehydrateGraphQlError = (error: any): GraphQLError => {\n  if (typeof error === 'string') {\n    return new GraphQLError(error);\n  } else if (typeof error === 'object' && error.message) {\n    return new GraphQLError(\n      error.message,\n      error.nodes,\n      error.source,\n      error.positions,\n      error.path,\n      error,\n      error.extensions || {}\n    );\n  } else {\n    return error as any;\n  }\n};\n\n/** An error which can consist of GraphQL errors and Network errors. */\nexport class CombinedError extends Error {\n  public name: string;\n  public message: string;\n  public graphQLErrors: GraphQLError[];\n  public networkError?: Error;\n  public response?: any;\n\n  constructor({\n    networkError,\n    graphQLErrors,\n    response,\n  }: {\n    networkError?: Error;\n    graphQLErrors?: Array<string | Partial<GraphQLError> | Error>;\n    response?: any;\n  }) {\n    const normalizedGraphQLErrors = (graphQLErrors || []).map(\n      rehydrateGraphQlError\n    );\n    const message = generateErrorMessage(networkError, normalizedGraphQLErrors);\n\n    super(message);\n\n    this.name = 'CombinedError';\n    this.message = message;\n    this.graphQLErrors = normalizedGraphQLErrors;\n    this.networkError = networkError;\n    this.response = response;\n  }\n\n  toString() {\n    return this.message;\n  }\n}\n", "// When we have separate strings it's useful to run a progressive\n// version of djb2 where we pretend that we're still looping over\n// the same string\nexport const phash = (h: number, x: string): number => {\n  h = h | 0;\n  for (let i = 0, l = x.length | 0; i < l; i++) {\n    h = (h << 5) + h + x.charCodeAt(i);\n  }\n\n  return h;\n};\n\n// This is a djb2 hashing function\nexport const hash = (x: string): number => phash(5381 | 0, x) >>> 0;\n", "const seen = new Set();\nconst cache = new WeakMap();\n\nconst stringify = (x: any): string => {\n  if (x === null || seen.has(x)) {\n    return 'null';\n  } else if (typeof x !== 'object') {\n    return JSON.stringify(x) || '';\n  } else if (x.toJSON) {\n    return stringify(x.toJSON());\n  } else if (Array.isArray(x)) {\n    let out = '[';\n    for (let i = 0, l = x.length; i < l; i++) {\n      if (i > 0) out += ',';\n      const value = stringify(x[i]);\n      out += value.length > 0 ? value : 'null';\n    }\n\n    out += ']';\n    return out;\n  }\n\n  const keys = Object.keys(x).sort();\n  if (!keys.length && x.constructor && x.constructor !== Object) {\n    const key = cache.get(x) || Math.random().toString(36).slice(2);\n    cache.set(x, key);\n    return `{\"__key\":\"${key}\"}`;\n  }\n\n  seen.add(x);\n  let out = '{';\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const key = keys[i];\n    const value = stringify(x[key]);\n    if (value) {\n      if (out.length > 1) out += ',';\n      out += stringify(key) + ':' + value;\n    }\n  }\n\n  seen.delete(x);\n  out += '}';\n  return out;\n};\n\nexport const stringifyVariables = (x: any): string => {\n  seen.clear();\n  return stringify(x);\n};\n", "import { TypedDocumentNode } from '@graphql-typed-document-node/core';\n\nimport {\n  Location,\n  DefinitionNode,\n  DocumentNode,\n  Kind,\n  parse,\n  print,\n} from 'graphql';\n\nimport { hash, phash } from './hash';\nimport { stringifyVariables } from './stringifyVariables';\nimport { GraphQLRequest } from '../types';\n\ninterface WritableLocation {\n  loc: Location | undefined;\n}\n\nexport interface KeyedDocumentNode extends DocumentNode {\n  __key: number;\n}\n\nexport const stringifyDocument = (\n  node: string | DefinitionNode | DocumentNode\n): string => {\n  let str = (typeof node !== 'string'\n    ? (node.loc && node.loc.source.body) || print(node)\n    : node\n  )\n    .replace(/([\\s,]|#[^\\n\\r]+)+/g, ' ')\n    .trim();\n\n  if (typeof node !== 'string') {\n    const operationName = 'definitions' in node && getOperationName(node);\n    if (operationName) {\n      str = `# ${operationName}\\n${str}`;\n    }\n\n    if (!node.loc) {\n      (node as WritableLocation).loc = {\n        start: 0,\n        end: str.length,\n        source: {\n          body: str,\n          name: 'gql',\n          locationOffset: { line: 1, column: 1 },\n        },\n      } as Location;\n    }\n  }\n\n  return str;\n};\n\nconst docs = new Map<number, KeyedDocumentNode>();\n\nexport const keyDocument = (q: string | DocumentNode): KeyedDocumentNode => {\n  let key: number;\n  let query: DocumentNode;\n  if (typeof q === 'string') {\n    key = hash(stringifyDocument(q));\n    query = docs.get(key) || parse(q, { noLocation: true });\n  } else {\n    key = (q as KeyedDocumentNode).__key || hash(stringifyDocument(q));\n    query = docs.get(key) || q;\n  }\n\n  // Add location information if it's missing\n  if (!query.loc) stringifyDocument(query);\n\n  (query as KeyedDocumentNode).__key = key;\n  docs.set(key, query as KeyedDocumentNode);\n  return query as KeyedDocumentNode;\n};\n\nexport const createRequest = <Data = any, Variables = object>(\n  q: string | DocumentNode | TypedDocumentNode<Data, Variables>,\n  vars?: Variables\n): GraphQLRequest<Data, Variables> => {\n  if (!vars) vars = {} as Variables;\n  const query = keyDocument(q);\n  return {\n    key: phash(query.__key, stringifyVariables(vars)) >>> 0,\n    query,\n    variables: vars,\n  };\n};\n\n/**\n * Finds the Name value from the OperationDefinition of a Document\n */\nexport const getOperationName = (query: DocumentNode): string | undefined => {\n  for (let i = 0, l = query.definitions.length; i < l; i++) {\n    const node = query.definitions[i];\n    if (node.kind === Kind.OPERATION_DEFINITION && node.name) {\n      return node.name.value;\n    }\n  }\n};\n\n/**\n * Finds the operation-type\n */\nexport const getOperationType = (query: DocumentNode): string | undefined => {\n  for (let i = 0, l = query.definitions.length; i < l; i++) {\n    const node = query.definitions[i];\n    if (node.kind === Kind.OPERATION_DEFINITION) {\n      return node.operation;\n    }\n  }\n};\n", "import { ExecutionResult, Operation, OperationResult } from '../types';\nimport { CombinedError } from './error';\n\nexport const makeResult = (\n  operation: Operation,\n  result: ExecutionResult,\n  response?: any\n): OperationResult => {\n  if ((!('data' in result) && !('errors' in result)) || 'path' in result) {\n    throw new Error('No Content');\n  }\n\n  return {\n    operation,\n    data: result.data,\n    error: Array.isArray(result.errors)\n      ? new CombinedError({\n          graphQLErrors: result.errors,\n          response,\n        })\n      : undefined,\n    extensions:\n      (typeof result.extensions === 'object' && result.extensions) || undefined,\n    hasNext: !!result.hasNext,\n  };\n};\n\nexport const mergeResultPatch = (\n  prevResult: OperationResult,\n  patch: ExecutionResult,\n  response?: any\n): OperationResult => {\n  const result = { ...prevResult };\n  result.hasNext = !!patch.hasNext;\n\n  if (!('path' in patch)) {\n    if ('data' in patch) result.data = patch.data;\n    return result;\n  }\n\n  if (Array.isArray(patch.errors)) {\n    result.error = new CombinedError({\n      graphQLErrors: result.error\n        ? [...result.error.graphQLErrors, ...patch.errors]\n        : patch.errors,\n      response,\n    });\n  }\n\n  let part: Record<string, any> | Array<any> = (result.data = {\n    ...result.data,\n  });\n\n  let i = 0;\n  let prop: string | number;\n  while (i < patch.path.length) {\n    prop = patch.path[i++];\n    part = part[prop] = Array.isArray(part[prop])\n      ? [...part[prop]]\n      : { ...part[prop] };\n  }\n\n  Object.assign(part, patch.data);\n  return result;\n};\n\nexport const makeErrorResult = (\n  operation: Operation,\n  error: Error,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: undefined,\n  error: new CombinedError({\n    networkError: error,\n    response,\n  }),\n  extensions: undefined,\n});\n", "import { DocumentNode, print } from 'graphql';\n\nimport { getOperationName, stringifyVariables } from '../utils';\nimport { Operation } from '../types';\n\nexport interface FetchBody {\n  query?: string;\n  operationName: string | undefined;\n  variables: undefined | Record<string, any>;\n  extensions: undefined | Record<string, any>;\n}\n\nconst shouldUseGet = (operation: Operation): boolean => {\n  return operation.kind === 'query' && !!operation.context.preferGetMethod;\n};\n\nexport const makeFetchBody = (request: {\n  query: DocumentNode;\n  variables?: object;\n}): FetchBody => ({\n  query: print(request.query),\n  operationName: getOperationName(request.query),\n  variables: request.variables || undefined,\n  extensions: undefined,\n});\n\nexport const makeFetchURL = (\n  operation: Operation,\n  body?: FetchBody\n): string => {\n  const useGETMethod = shouldUseGet(operation);\n  const url = operation.context.url;\n  if (!useGETMethod || !body) return url;\n\n  const search: string[] = [];\n  if (body.operationName) {\n    search.push('operationName=' + encodeURIComponent(body.operationName));\n  }\n\n  if (body.query) {\n    search.push(\n      'query=' +\n        encodeURIComponent(body.query.replace(/#[^\\n\\r]+/g, ' ').trim())\n    );\n  }\n\n  if (body.variables) {\n    search.push(\n      'variables=' + encodeURIComponent(stringifyVariables(body.variables))\n    );\n  }\n\n  if (body.extensions) {\n    search.push(\n      'extensions=' + encodeURIComponent(stringifyVariables(body.extensions))\n    );\n  }\n\n  return `${url}?${search.join('&')}`;\n};\n\nexport const makeFetchOptions = (\n  operation: Operation,\n  body?: FetchBody\n): RequestInit => {\n  const useGETMethod = shouldUseGet(operation);\n\n  const extraOptions =\n    typeof operation.context.fetchOptions === 'function'\n      ? operation.context.fetchOptions()\n      : operation.context.fetchOptions || {};\n\n  return {\n    ...extraOptions,\n    body: !useGETMethod && body ? JSON.stringify(body) : undefined,\n    method: useGETMethod ? 'GET' : 'POST',\n    headers: useGETMethod\n      ? extraOptions.headers\n      : { 'content-type': 'application/json', ...extraOptions.headers },\n  };\n};\n", "import { Source, make } from 'wonka';\nimport { Operation, OperationResult } from '../types';\nimport { makeResult, makeErrorResult, mergeResultPatch } from '../utils';\n\nconst asyncIterator =\n  typeof Symbol !== 'undefined' ? Symbol.asyncIterator : null;\nconst decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder() : null;\nconst jsonHeaderRe = /content-type:[^\\r\\n]*application\\/json/i;\nconst boundaryHeaderRe = /boundary=\"?([^=\";]+)\"?/i;\n\ntype ChunkData = { done: false; value: Buffer | Uint8Array } | { done: true };\n\n// NOTE: We're avoiding referencing the `Buffer` global here to prevent\n// auto-polyfilling in Webpack\nconst toString = (input: Buffer | ArrayBuffer): string =>\n  input.constructor.name === 'Buffer'\n    ? (input as Buffer).toString()\n    : decoder!.decode(input as ArrayBuffer);\n\n// DERIVATIVE: Copyright (c) 2021 Marais Rossouw <hi@marais.io>\n// See: https://github.com/maraisr/meros/blob/219fe95/src/browser.ts\nconst executeIncrementalFetch = (\n  onResult: (result: OperationResult) => void,\n  operation: Operation,\n  response: Response\n): Promise<void> => {\n  // NOTE: Guarding against fetch polyfills here\n  const contentType =\n    (response.headers && response.headers.get('Content-Type')) || '';\n  if (!/multipart\\/mixed/i.test(contentType)) {\n    return response.json().then(payload => {\n      onResult(makeResult(operation, payload, response));\n    });\n  }\n\n  let boundary = '---';\n  const boundaryHeader = contentType.match(boundaryHeaderRe);\n  if (boundaryHeader) boundary = '--' + boundaryHeader[1];\n\n  let read: () => Promise<ChunkData>;\n  let cancel = () => {\n    /*noop*/\n  };\n  if (asyncIterator && response[asyncIterator]) {\n    const iterator = response[asyncIterator]();\n    read = iterator.next.bind(iterator);\n  } else if ('body' in response && response.body) {\n    const reader = response.body.getReader();\n    cancel = reader.cancel.bind(reader);\n    read = reader.read.bind(reader);\n  } else {\n    throw new TypeError('Streaming requests unsupported');\n  }\n\n  let buffer = '';\n  let isPreamble = true;\n  let nextResult: OperationResult | null = null;\n  let prevResult: OperationResult | null = null;\n\n  function next(data: ChunkData): Promise<void> | void {\n    if (!data.done) {\n      const chunk = toString(data.value);\n      let boundaryIndex = chunk.indexOf(boundary);\n      if (boundaryIndex > -1) {\n        boundaryIndex += buffer.length;\n      } else {\n        boundaryIndex = buffer.indexOf(boundary);\n      }\n\n      buffer += chunk;\n      while (boundaryIndex > -1) {\n        const current = buffer.slice(0, boundaryIndex);\n        const next = buffer.slice(boundaryIndex + boundary.length);\n\n        if (isPreamble) {\n          isPreamble = false;\n        } else {\n          const headersEnd = current.indexOf('\\r\\n\\r\\n') + 4;\n          const headers = current.slice(0, headersEnd);\n          const body = current.slice(headersEnd, current.lastIndexOf('\\r\\n'));\n\n          let payload: any;\n          if (jsonHeaderRe.test(headers)) {\n            try {\n              payload = JSON.parse(body);\n              nextResult = prevResult = prevResult\n                ? mergeResultPatch(prevResult, payload, response)\n                : makeResult(operation, payload, response);\n            } catch (_error) {}\n          }\n\n          if (next.slice(0, 2) === '--' || (payload && !payload.hasNext)) {\n            if (!prevResult)\n              return onResult(makeResult(operation, {}, response));\n            break;\n          }\n        }\n\n        buffer = next;\n        boundaryIndex = buffer.indexOf(boundary);\n      }\n    }\n\n    if (nextResult) {\n      onResult(nextResult);\n      nextResult = null;\n    }\n\n    if (!data.done && (!prevResult || prevResult.hasNext)) {\n      return read().then(next);\n    }\n  }\n\n  return read().then(next).finally(cancel);\n};\n\nexport const makeFetchSource = (\n  operation: Operation,\n  url: string,\n  fetchOptions: RequestInit\n): Source<OperationResult> => {\n  const maxStatus = fetchOptions.redirect === 'manual' ? 400 : 300;\n  const fetcher = operation.context.fetch;\n\n  return make<OperationResult>(({ next, complete }) => {\n    const abortController =\n      typeof AbortController !== 'undefined' ? new AbortController() : null;\n    if (abortController) {\n      fetchOptions.signal = abortController.signal;\n    }\n\n    let ended = false;\n    let statusNotOk = false;\n    let response: Response;\n\n    Promise.resolve()\n      .then(() => {\n        if (ended) return;\n        return (fetcher || fetch)(url, fetchOptions);\n      })\n      .then((_response: Response | void) => {\n        if (!_response) return;\n        response = _response;\n        statusNotOk = response.status < 200 || response.status >= maxStatus;\n        return executeIncrementalFetch(next, operation, response);\n      })\n      .then(complete)\n      .catch((error: Error) => {\n        if (error.name !== 'AbortError') {\n          const result = makeErrorResult(\n            operation,\n            statusNotOk ? new Error(response.statusText) : error,\n            response\n          );\n\n          next(result);\n          complete();\n        }\n      });\n\n    return () => {\n      ended = true;\n      if (abortController) {\n        abortController.abort();\n      }\n    };\n  });\n};\n", "import {\n  DocumentNode,\n  FieldNode,\n  InlineFragmentNode,\n  SelectionNode,\n  Kind,\n  visit,\n} from 'graphql';\n\nimport { KeyedDocumentNode, keyDocument } from './request';\n\ninterface EntityLike {\n  [key: string]: EntityLike | EntityLike[] | any;\n  __typename: string | null | void;\n}\n\nconst collectTypes = (\n  obj: EntityLike | EntityLike[],\n  types: { [typename: string]: unknown }\n) => {\n  if (Array.isArray(obj)) {\n    for (let i = 0; i < obj.length; i++) collectTypes(obj[i], types);\n  } else if (typeof obj === 'object' && obj !== null) {\n    for (const key in obj) {\n      if (key === '__typename' && typeof obj[key] === 'string') {\n        types[obj[key] as string] = 0;\n      } else {\n        collectTypes(obj[key], types);\n      }\n    }\n  }\n\n  return types;\n};\n\nexport const collectTypesFromResponse = (response: object) =>\n  Object.keys(collectTypes(response as EntityLike, {}));\n\nconst formatNode = (node: FieldNode | InlineFragmentNode) => {\n  if (\n    node.selectionSet &&\n    !node.selectionSet.selections.some(\n      node =>\n        node.kind === Kind.FIELD &&\n        node.name.value === '__typename' &&\n        !node.alias\n    )\n  ) {\n    return {\n      ...node,\n      selectionSet: {\n        ...node.selectionSet,\n        selections: [\n          ...(node.selectionSet.selections as SelectionNode[]),\n          {\n            kind: Kind.FIELD,\n            name: {\n              kind: Kind.NAME,\n              value: '__typename',\n            },\n          },\n        ],\n      },\n    };\n  }\n};\n\nconst formattedDocs = new Map<number, KeyedDocumentNode>();\n\nexport const formatDocument = <T extends DocumentNode>(node: T): T => {\n  const query = keyDocument(node);\n\n  let result = formattedDocs.get(query.__key);\n  if (!result) {\n    result = visit(query, {\n      Field: formatNode,\n      InlineFragment: formatNode,\n    }) as KeyedDocumentNode;\n\n    // Ensure that the hash of the resulting document won't suddenly change\n    // we are marking __key as non-enumerable so when external exchanges use visit\n    // to manipulate a document we won't restore the previous query due to the __key\n    // property.\n    Object.defineProperty(result, '__key', {\n      value: query.__key,\n      enumerable: false,\n    });\n\n    formattedDocs.set(query.__key, result);\n  }\n\n  return (result as unknown) as T;\n};\n", "export const maskTypename = (data: any): any => {\n  if (!data || typeof data !== 'object') return data;\n\n  return Object.keys(data).reduce(\n    (acc, key: string) => {\n      const value = data[key];\n      if (key === '__typename') {\n        Object.defineProperty(acc, '__typename', {\n          enumerable: false,\n          value,\n        });\n      } else if (Array.isArray(value)) {\n        acc[key] = value.map(maskTypename);\n      } else if (value && typeof value === 'object' && '__typename' in value) {\n        acc[key] = maskTypename(value);\n      } else {\n        acc[key] = value;\n      }\n\n      return acc;\n    },\n    Array.isArray(data) ? [] : {}\n  );\n};\n", "import { Source, pipe, toPromise, filter, take } from 'wonka';\nimport { OperationResult, PromisifiedSource } from '../types';\n\nexport function withPromise<T extends OperationResult>(\n  source$: Source<T>\n): PromisifiedSource<T> {\n  (source$ as PromisifiedSource<T>).toPromise = () => {\n    return pipe(\n      source$,\n      filter(result => !result.stale && !result.hasNext),\n      take(1),\n      toPromise\n    );\n  };\n\n  return source$ as PromisifiedSource<T>;\n}\n", "import {\n  GraphQLRequest,\n  Operation,\n  OperationContext,\n  OperationType,\n} from '../types';\n\nfunction makeOperation<Data = any, Variables = object>(\n  kind: OperationType,\n  request: GraphQLRequest<Data, Variables>,\n  context: OperationContext\n): Operation<Data, Variables>;\n\nfunction makeOperation<Data = any, Variables = object>(\n  kind: OperationType,\n  request: Operation<Data, Variables>,\n  context?: OperationContext\n): Operation<Data, Variables>;\n\nfunction makeOperation(kind, request, context) {\n  if (!context) context = request.context;\n\n  return {\n    key: request.key,\n    query: request.query,\n    variables: request.variables,\n    kind,\n    context,\n  };\n}\n\nexport { makeOperation };\n\n/** Spreads the provided metadata to the source operation's meta property in context.  */\nexport const addMetadata = (\n  operation: Operation,\n  meta: OperationContext['meta']\n) => {\n  return makeOperation(operation.kind, operation, {\n    ...operation.context,\n    meta: {\n      ...operation.context.meta,\n      ...meta,\n    },\n  });\n};\n", "/* eslint-disable prefer-rest-params */\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\n\nimport {\n  DocumentNode,\n  DefinitionNode,\n  FragmentDefinitionNode,\n  Kind,\n} from 'graphql';\n\nimport { keyDocument, stringifyDocument } from './utils';\n\nconst applyDefinitions = (\n  fragmentNames: Map<string, string>,\n  target: DefinitionNode[],\n  source: Array<DefinitionNode> | ReadonlyArray<DefinitionNode>\n) => {\n  for (let i = 0; i < source.length; i++) {\n    if (source[i].kind === Kind.FRAGMENT_DEFINITION) {\n      const name = (source[i] as FragmentDefinitionNode).name.value;\n      const value = stringifyDocument(source[i]);\n      // Fragments will be deduplicated according to this Map\n      if (!fragmentNames.has(name)) {\n        fragmentNames.set(name, value);\n        target.push(source[i]);\n      } else if (\n        process.env.NODE_ENV !== 'production' &&\n        fragmentNames.get(name) !== value\n      ) {\n        // Fragments with the same names is expected to have the same contents\n        console.warn(\n          '[WARNING: Duplicate Fragment] A fragment with name `' +\n            name +\n            '` already exists in this document.\\n' +\n            'While fragment names may not be unique across your source, each name must be unique per document.'\n        );\n      }\n    } else {\n      target.push(source[i]);\n    }\n  }\n};\n\nfunction gql<Data = any, Variables = object>(\n  strings: TemplateStringsArray,\n  ...interpolations: Array<TypedDocumentNode | DocumentNode | string>\n): TypedDocumentNode<Data, Variables>;\n\nfunction gql<Data = any, Variables = object>(\n  string: string\n): TypedDocumentNode<Data, Variables>;\n\nfunction gql(/* arguments */) {\n  const fragmentNames = new Map<string, string>();\n  const definitions: DefinitionNode[] = [];\n  const interpolations: DefinitionNode[] = [];\n\n  // Apply the entire tagged template body's definitions\n  let body: string = Array.isArray(arguments[0])\n    ? arguments[0][0]\n    : arguments[0] || '';\n  for (let i = 1; i < arguments.length; i++) {\n    const value = arguments[i];\n    if (value && value.definitions) {\n      interpolations.push(...value.definitions);\n    } else {\n      body += value;\n    }\n\n    body += arguments[0][i];\n  }\n\n  // Apply the tag's body definitions\n  applyDefinitions(fragmentNames, definitions, keyDocument(body).definitions);\n  // Copy over each interpolated document's definitions\n  applyDefinitions(fragmentNames, definitions, interpolations);\n\n  return keyDocument({\n    kind: Kind.DOCUMENT,\n    definitions,\n  });\n}\n\nexport { gql };\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { filter, map, merge, pipe, share, tap } from 'wonka';\n\nimport { Client } from '../client';\nimport { Exchange, Operation, OperationResult } from '../types';\n\nimport {\n  makeOperation,\n  addMetadata,\n  collectTypesFromResponse,\n  formatDocument,\n} from '../utils';\n\ntype ResultCache = Map<number, OperationResult>;\n\ninterface OperationCache {\n  [key: string]: Set<number>;\n}\n\nconst shouldSkip = ({ kind }: Operation) =>\n  kind !== 'mutation' && kind !== 'query';\n\nexport const cacheExchange: Exchange = ({ forward, client, dispatchDebug }) => {\n  const resultCache = new Map() as ResultCache;\n  const operationCache = Object.create(null) as OperationCache;\n\n  // Adds unique typenames to query (for invalidating cache entries)\n  const mapTypeNames = (operation: Operation): Operation => {\n    const formattedOperation = makeOperation(operation.kind, operation);\n    formattedOperation.query = formatDocument(operation.query);\n    return formattedOperation;\n  };\n\n  const isOperationCached = (operation: Operation) => {\n    const {\n      key,\n      kind,\n      context: { requestPolicy },\n    } = operation;\n    return (\n      kind === 'query' &&\n      requestPolicy !== 'network-only' &&\n      (requestPolicy === 'cache-only' || resultCache.has(key))\n    );\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n\n    const cachedOps$ = pipe(\n      sharedOps$,\n      filter(op => !shouldSkip(op) && isOperationCached(op)),\n      map(operation => {\n        const cachedResult = resultCache.get(operation.key);\n\n        dispatchDebug({\n          operation,\n          ...(cachedResult\n            ? {\n                type: 'cacheHit',\n                message: 'The result was successfully retried from the cache',\n              }\n            : {\n                type: 'cacheMiss',\n                message: 'The result could not be retrieved from the cache',\n              }),\n        });\n\n        const result: OperationResult = {\n          ...cachedResult,\n          operation: addMetadata(operation, {\n            cacheOutcome: cachedResult ? 'hit' : 'miss',\n          }),\n        };\n\n        if (operation.context.requestPolicy === 'cache-and-network') {\n          result.stale = true;\n          reexecuteOperation(client, operation);\n        }\n\n        return result;\n      })\n    );\n\n    const forwardedOps$ = pipe(\n      merge([\n        pipe(\n          sharedOps$,\n          filter(op => !shouldSkip(op) && !isOperationCached(op)),\n          map(mapTypeNames)\n        ),\n        pipe(\n          sharedOps$,\n          filter(op => shouldSkip(op))\n        ),\n      ]),\n      map(op => addMetadata(op, { cacheOutcome: 'miss' })),\n      filter(\n        op => op.kind !== 'query' || op.context.requestPolicy !== 'cache-only'\n      ),\n      forward,\n      tap(response => {\n        let { operation } = response;\n        if (!operation) return;\n\n        const typenames = collectTypesFromResponse(response.data).concat(\n          operation.context.additionalTypenames || []\n        );\n\n        // Invalidates the cache given a mutation's response\n        if (response.operation.kind === 'mutation') {\n          const pendingOperations = new Set<number>();\n\n          dispatchDebug({\n            type: 'cacheInvalidation',\n            message: `The following typenames have been invalidated: ${typenames}`,\n            operation,\n            data: { typenames, response },\n          });\n\n          for (let i = 0; i < typenames.length; i++) {\n            const typeName = typenames[i];\n            const operations =\n              operationCache[typeName] ||\n              (operationCache[typeName] = new Set());\n            operations.forEach(key => {\n              pendingOperations.add(key);\n            });\n            operations.clear();\n          }\n\n          pendingOperations.forEach(key => {\n            if (resultCache.has(key)) {\n              operation = (resultCache.get(key) as OperationResult).operation;\n              resultCache.delete(key);\n              reexecuteOperation(client, operation);\n            }\n          });\n          // Mark typenames on typenameInvalidate for early invalidation\n        } else if (operation.kind === 'query' && response.data) {\n          resultCache.set(operation.key, response);\n          for (let i = 0; i < typenames.length; i++) {\n            const typeName = typenames[i];\n            const operations =\n              operationCache[typeName] ||\n              (operationCache[typeName] = new Set());\n            operations.add(operation.key);\n          }\n        }\n      })\n    );\n\n    return merge([cachedOps$, forwardedOps$]);\n  };\n};\n\n// Reexecutes a given operation with the default requestPolicy\nexport const reexecuteOperation = (client: Client, operation: Operation) => {\n  return client.reexecuteOperation(\n    makeOperation(operation.kind, operation, {\n      ...operation.context,\n      requestPolicy: 'network-only',\n    })\n  );\n};\n", "import { GraphQLError } from 'graphql';\nimport { pipe, share, filter, merge, map, tap } from 'wonka';\nimport { Exchange, OperationResult, Operation } from '../types';\nimport { CombinedError } from '../utils';\nimport { reexecuteOperation } from './cache';\n\nexport interface SerializedResult {\n  hasNext?: boolean;\n  data?: string | undefined; // JSON string of data\n  extensions?: string | undefined; // JSON string of data\n  error?: {\n    graphQLErrors: Array<Partial<GraphQLError> | string>;\n    networkError?: string;\n  };\n}\n\nexport interface SSRData {\n  [key: string]: SerializedResult;\n}\n\nexport interface SSRExchangeParams {\n  isClient?: boolean;\n  initialState?: SSRData;\n  staleWhileRevalidate?: boolean;\n  includeExtensions?: boolean;\n}\n\nexport interface SSRExchange extends Exchange {\n  /** Rehydrates cached data */\n  restoreData(data: SSRData): void;\n  /** Extracts cached data */\n  extractData(): SSRData;\n}\n\n/** Serialize an OperationResult to plain JSON */\nconst serializeResult = (\n  { hasNext, data, extensions, error }: OperationResult,\n  includeExtensions: boolean\n): SerializedResult => {\n  const result: SerializedResult = {};\n  if (data !== undefined) result.data = JSON.stringify(data);\n  if (includeExtensions && extensions !== undefined) {\n    result.extensions = JSON.stringify(extensions);\n  }\n  if (hasNext) result.hasNext = true;\n\n  if (error) {\n    result.error = {\n      graphQLErrors: error.graphQLErrors.map(error => {\n        if (!error.path && !error.extensions) return error.message;\n\n        return {\n          message: error.message,\n          path: error.path,\n          extensions: error.extensions,\n        };\n      }),\n    };\n\n    if (error.networkError) {\n      result.error.networkError = '' + error.networkError;\n    }\n  }\n\n  return result;\n};\n\n/** Deserialize plain JSON to an OperationResult */\nconst deserializeResult = (\n  operation: Operation,\n  result: SerializedResult,\n  includeExtensions: boolean\n): OperationResult => ({\n  operation,\n  data: result.data ? JSON.parse(result.data) : undefined,\n  extensions:\n    includeExtensions && result.extensions\n      ? JSON.parse(result.extensions)\n      : undefined,\n  error: result.error\n    ? new CombinedError({\n        networkError: result.error.networkError\n          ? new Error(result.error.networkError)\n          : undefined,\n        graphQLErrors: result.error.graphQLErrors,\n      })\n    : undefined,\n  hasNext: result.hasNext,\n});\n\nconst revalidated = new Set<number>();\n\n/** The ssrExchange can be created to capture data during SSR and also to rehydrate it on the client */\nexport const ssrExchange = (params?: SSRExchangeParams): SSRExchange => {\n  const staleWhileRevalidate = !!(params && params.staleWhileRevalidate);\n  const includeExtensions = !!(params && params.includeExtensions);\n  const data: Record<string, SerializedResult | null> = {};\n\n  // On the client-side, we delete results from the cache as they're resolved\n  // this is delayed so that concurrent queries don't delete each other's data\n  const invalidateQueue: number[] = [];\n  const invalidate = (result: OperationResult) => {\n    invalidateQueue.push(result.operation.key);\n    if (invalidateQueue.length === 1) {\n      Promise.resolve().then(() => {\n        let key: number | void;\n        while ((key = invalidateQueue.shift())) {\n          data[key] = null;\n        }\n      });\n    }\n  };\n\n  // The SSR Exchange is a temporary cache that can populate results into data for suspense\n  // On the client it can be used to retrieve these temporary results from a rehydrated cache\n  const ssr: SSRExchange = ({ client, forward }) => ops$ => {\n    // params.isClient tells us whether we're on the client-side\n    // By default we assume that we're on the client if suspense-mode is disabled\n    const isClient =\n      params && typeof params.isClient === 'boolean'\n        ? !!params.isClient\n        : !client.suspense;\n\n    const sharedOps$ = share(ops$);\n\n    let forwardedOps$ = pipe(\n      sharedOps$,\n      filter(\n        operation => !data[operation.key] || !!data[operation.key]!.hasNext\n      ),\n      forward\n    );\n\n    // NOTE: Since below we might delete the cached entry after accessing\n    // it once, cachedOps$ needs to be merged after forwardedOps$\n    let cachedOps$ = pipe(\n      sharedOps$,\n      filter(operation => !!data[operation.key]),\n      map(op => {\n        const serialized = data[op.key]!;\n        const result = deserializeResult(op, serialized, includeExtensions);\n        if (staleWhileRevalidate && !revalidated.has(op.key)) {\n          result.stale = true;\n          revalidated.add(op.key);\n          reexecuteOperation(client, op);\n        }\n\n        return result;\n      })\n    );\n\n    if (!isClient) {\n      // On the server we cache results in the cache as they're resolved\n      forwardedOps$ = pipe(\n        forwardedOps$,\n        tap((result: OperationResult) => {\n          const { operation } = result;\n          if (operation.kind !== 'mutation') {\n            const serialized = serializeResult(result, includeExtensions);\n            data[operation.key] = serialized;\n          }\n        })\n      );\n    } else {\n      // On the client we delete results from the cache as they're resolved\n      cachedOps$ = pipe(cachedOps$, tap(invalidate));\n    }\n\n    return merge([forwardedOps$, cachedOps$]);\n  };\n\n  ssr.restoreData = (restore: SSRData) => {\n    for (const key in restore) {\n      // We only restore data that hasn't been previously invalidated\n      if (data[key] !== null) {\n        data[key] = restore[key];\n      }\n    }\n  };\n\n  ssr.extractData = () => {\n    const result: SSRData = {};\n    for (const key in data) if (data[key] != null) result[key] = data[key]!;\n    return result;\n  };\n\n  if (params && params.initialState) {\n    ssr.restoreData(params.initialState);\n  }\n\n  return ssr;\n};\n", "import { print } from 'graphql';\n\nimport {\n  filter,\n  make,\n  merge,\n  mergeMap,\n  pipe,\n  share,\n  Source,\n  takeUntil,\n} from 'wonka';\n\nimport { makeResult, makeErrorResult, makeOperation } from '../utils';\n\nimport {\n  Exchange,\n  ExecutionResult,\n  Operation,\n  OperationContext,\n  OperationResult,\n} from '../types';\n\nexport interface ObserverLike<T> {\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\n/** An abstract observable interface conforming to: https://github.com/tc39/proposal-observable */\nexport interface ObservableLike<T> {\n  subscribe(\n    observer: ObserverLike<T>\n  ): {\n    unsubscribe: () => void;\n  };\n}\n\nexport interface SubscriptionOperation {\n  query: string;\n  variables?: Record<string, unknown>;\n  key: string;\n  context: OperationContext;\n}\n\nexport type SubscriptionForwarder = (\n  operation: SubscriptionOperation\n) => ObservableLike<ExecutionResult>;\n\n/** This is called to create a subscription and needs to be hooked up to a transport client. */\nexport interface SubscriptionExchangeOpts {\n  // This has been modelled to work with subscription-transport-ws\n  // See: https://github.com/apollographql/subscriptions-transport-ws#requestoptions--observableexecutionresult-returns-observable-to-execute-the-operation\n  forwardSubscription: SubscriptionForwarder;\n\n  /** This flag may be turned on to allow your subscriptions-transport to handle all operation types */\n  enableAllOperations?: boolean;\n}\n\nexport const subscriptionExchange = ({\n  forwardSubscription,\n  enableAllOperations,\n}: SubscriptionExchangeOpts): Exchange => ({ client, forward }) => {\n  const createSubscriptionSource = (\n    operation: Operation\n  ): Source<OperationResult> => {\n    // This excludes the query's name as a field although subscription-transport-ws does accept it since it's optional\n    const observableish = forwardSubscription({\n      key: operation.key.toString(36),\n      query: print(operation.query),\n      variables: operation.variables,\n      context: { ...operation.context },\n    });\n\n    return make<OperationResult>(({ next, complete }) => {\n      let isComplete = false;\n      let sub;\n\n      Promise.resolve().then(() => {\n        if (isComplete) return;\n\n        sub = observableish.subscribe({\n          next: result => next(makeResult(operation, result)),\n          error: err => next(makeErrorResult(operation, err)),\n          complete: () => {\n            if (!isComplete) {\n              isComplete = true;\n              if (operation.kind === 'subscription') {\n                client.reexecuteOperation(\n                  makeOperation('teardown', operation, operation.context)\n                );\n              }\n\n              complete();\n            }\n          },\n        });\n      });\n\n      return () => {\n        isComplete = true;\n        if (sub) sub.unsubscribe();\n      };\n    });\n  };\n\n  const isSubscriptionOperation = (operation: Operation): boolean => {\n    const { kind } = operation;\n    return (\n      kind === 'subscription' ||\n      (!!enableAllOperations && (kind === 'query' || kind === 'mutation'))\n    );\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n    const subscriptionResults$ = pipe(\n      sharedOps$,\n      filter(isSubscriptionOperation),\n      mergeMap(operation => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.kind === 'teardown' && op.key === key)\n        );\n\n        return pipe(createSubscriptionSource(operation), takeUntil(teardown$));\n      })\n    );\n\n    const forward$ = pipe(\n      sharedOps$,\n      filter(op => !isSubscriptionOperation(op)),\n      forward\n    );\n\n    return merge([subscriptionResults$, forward$]);\n  };\n};\n", "import { filter, pipe, tap } from 'wonka';\nimport { Exchange, Operation, OperationResult } from '../types';\n\n/** A default exchange for debouncing GraphQL requests. */\nexport const dedupExchange: Exchange = ({ forward, dispatchDebug }) => {\n  const inFlightKeys = new Set<number>();\n\n  const filterIncomingOperation = (operation: Operation) => {\n    const { key, kind } = operation;\n    if (kind === 'teardown') {\n      inFlightKeys.delete(key);\n      return true;\n    }\n\n    if (kind !== 'query' && kind !== 'subscription') {\n      return true;\n    }\n\n    const isInFlight = inFlightKeys.has(key);\n    inFlightKeys.add(key);\n\n    if (isInFlight) {\n      dispatchDebug({\n        type: 'dedup',\n        message: 'An operation has been deduped.',\n        operation,\n      });\n    }\n\n    return !isInFlight;\n  };\n\n  const afterOperationResult = ({ operation, hasNext }: OperationResult) => {\n    if (!hasNext) {\n      inFlightKeys.delete(operation.key);\n    }\n  };\n\n  return ops$ => {\n    const forward$ = pipe(ops$, filter(filterIncomingOperation));\n    return pipe(forward(forward$), tap(afterOperationResult));\n  };\n};\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { filter, merge, mergeMap, pipe, share, takeUntil, onPush } from 'wonka';\n\nimport { Exchange } from '../types';\nimport {\n  makeFetchBody,\n  makeFetchURL,\n  makeFetchOptions,\n  makeFetchSource,\n} from '../internal';\n\n/** A default exchange for fetching GraphQL requests. */\nexport const fetchExchange: Exchange = ({ forward, dispatchDebug }) => {\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n    const fetchResults$ = pipe(\n      sharedOps$,\n      filter(operation => {\n        return operation.kind === 'query' || operation.kind === 'mutation';\n      }),\n      mergeMap(operation => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.kind === 'teardown' && op.key === key)\n        );\n\n        const body = makeFetchBody(operation);\n        const url = makeFetchURL(operation, body);\n        const fetchOptions = makeFetchOptions(operation, body);\n\n        dispatchDebug({\n          type: 'fetchRequest',\n          message: 'A fetch request is being executed.',\n          operation,\n          data: {\n            url,\n            fetchOptions,\n          },\n        });\n\n        return pipe(\n          makeFetchSource(operation, url, fetchOptions),\n          takeUntil(teardown$),\n          onPush(result => {\n            const error = !result.data ? result.error : undefined;\n\n            dispatchDebug({\n              type: error ? 'fetchError' : 'fetchSuccess',\n              message: `A ${\n                error ? 'failed' : 'successful'\n              } fetch response has been returned.`,\n              operation,\n              data: {\n                url,\n                fetchOptions,\n                value: error || result,\n              },\n            });\n          })\n        );\n      })\n    );\n\n    const forward$ = pipe(\n      sharedOps$,\n      filter(operation => {\n        return operation.kind !== 'query' && operation.kind !== 'mutation';\n      }),\n      forward\n    );\n\n    return merge([fetchResults$, forward$]);\n  };\n};\n", "import { filter, pipe, tap } from 'wonka';\nimport { Operation, ExchangeIO, ExchangeInput } from '../types';\nimport { noop } from '../utils';\n\n/** This is always the last exchange in the chain; No operation should ever reach it */\nexport const fallbackExchange: ({\n  dispatchDebug,\n}: Pick<ExchangeInput, 'dispatchDebug'>) => ExchangeIO = ({\n  dispatchDebug,\n}) => ops$ =>\n  pipe(\n    ops$,\n    tap<Operation>(operation => {\n      if (\n        operation.kind !== 'teardown' &&\n        process.env.NODE_ENV !== 'production'\n      ) {\n        const message = `No exchange has handled operations of kind \"${operation.kind}\". Check whether you've added an exchange responsible for these operations.`;\n\n        dispatchDebug({\n          type: 'fallbackCatch',\n          message,\n          operation,\n        });\n        console.warn(message);\n      }\n    }),\n    /* All operations that skipped through the entire exchange chain should be filtered from the output */\n    filter<any>(() => false)\n  );\n\nexport const fallbackExchangeIO: ExchangeIO = fallbackExchange({\n  dispatchDebug: noop,\n});\n", "import { Exchange, ExchangeInput } from '../types';\n\n/** This composes an array of Exchanges into a single ExchangeIO function */\nexport const composeExchanges = (exchanges: Exchange[]) => ({\n  client,\n  forward,\n  dispatchDebug,\n}: ExchangeInput) =>\n  exchanges.reduceRight(\n    (forward, exchange) =>\n      exchange({\n        client,\n        forward,\n        dispatchDebug(event) {\n          dispatchDebug({\n            timestamp: Date.now(),\n            source: exchange.name,\n            ...event,\n          });\n        },\n      }),\n    forward\n  );\n", "import { pipe, tap } from 'wonka';\nimport { Exchange, Operation } from '../types';\nimport { CombinedError } from '../utils';\n\nexport const errorExchange = ({\n  onError,\n}: {\n  onError: (error: CombinedError, operation: Operation) => void;\n}): Exchange => ({ forward }) => ops$ => {\n  return pipe(\n    forward(ops$),\n    tap(({ error, operation }) => {\n      if (error) {\n        onError(error, operation);\n      }\n    })\n  );\n};\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\n\nimport {\n  filter,\n  make,\n  makeSubject,\n  onEnd,\n  onPush,\n  onStart,\n  pipe,\n  share,\n  Source,\n  take,\n  takeUntil,\n  publish,\n  subscribe,\n  switchMap,\n  fromValue,\n  merge,\n  map,\n  Subscription,\n} from 'wonka';\n\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport { DocumentNode } from 'graphql';\n\nimport { composeExchanges, defaultExchanges } from './exchanges';\nimport { fallbackExchange } from './exchanges/fallback';\n\nimport {\n  Exchange,\n  ExchangeInput,\n  GraphQLRequest,\n  Operation,\n  OperationContext,\n  OperationResult,\n  OperationType,\n  RequestPolicy,\n  PromisifiedSource,\n  DebugEvent,\n} from './types';\n\nimport {\n  createRequest,\n  withPromise,\n  maskTypename,\n  noop,\n  makeOperation,\n  getOperationType,\n} from './utils';\n\n/** Options for configuring the URQL [client]{@link Client}. */\nexport interface ClientOptions {\n  /** Target endpoint URL such as `https://my-target:8080/graphql`. */\n  url: string;\n  /** Any additional options to pass to fetch. */\n  fetchOptions?: RequestInit | (() => RequestInit);\n  /** An alternative fetch implementation. */\n  fetch?: typeof fetch;\n  /** An ordered array of Exchanges. */\n  exchanges?: Exchange[];\n  /** Activates support for Suspense. */\n  suspense?: boolean;\n  /** The default request policy for requests. */\n  requestPolicy?: RequestPolicy;\n  /** Use HTTP GET for queries. */\n  preferGetMethod?: boolean;\n  /** Mask __typename from results. */\n  maskTypename?: boolean;\n}\n\nexport interface Client {\n  new (options: ClientOptions): Client;\n\n  operations$: Source<Operation>;\n\n  /** Start an operation from an exchange */\n  reexecuteOperation: (operation: Operation) => void;\n  /** Event target for monitoring, e.g. for @urql/devtools */\n  subscribeToDebugTarget?: (onEvent: (e: DebugEvent) => void) => Subscription;\n\n  // These are variables derived from ClientOptions\n  url: string;\n  fetch?: typeof fetch;\n  fetchOptions?: RequestInit | (() => RequestInit);\n  suspense: boolean;\n  requestPolicy: RequestPolicy;\n  preferGetMethod: boolean;\n  maskTypename: boolean;\n\n  createOperationContext(\n    opts?: Partial<OperationContext> | undefined\n  ): OperationContext;\n\n  createRequestOperation<Data = any, Variables = object>(\n    kind: OperationType,\n    request: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): Operation<Data, Variables>;\n\n  /** Executes an Operation by sending it through the exchange pipeline It returns an observable that emits all related exchange results and keeps track of this observable's subscribers. A teardown signal will be emitted when no subscribers are listening anymore. */\n  executeRequestOperation<Data = any, Variables = object>(\n    operation: Operation<Data, Variables>\n  ): Source<OperationResult<Data, Variables>>;\n\n  query<Data = any, Variables extends object = {}>(\n    query: DocumentNode | TypedDocumentNode<Data, Variables> | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): PromisifiedSource<OperationResult<Data, Variables>>;\n\n  readQuery<Data = any, Variables extends object = {}>(\n    query: DocumentNode | TypedDocumentNode<Data, Variables> | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): OperationResult<Data, Variables> | null;\n\n  executeQuery<Data = any, Variables = object>(\n    query: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): Source<OperationResult<Data, Variables>>;\n\n  subscription<Data = any, Variables extends object = {}>(\n    query: DocumentNode | TypedDocumentNode<Data, Variables> | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): Source<OperationResult<Data, Variables>>;\n\n  executeSubscription<Data = any, Variables = object>(\n    query: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): Source<OperationResult<Data, Variables>>;\n\n  mutation<Data = any, Variables extends object = {}>(\n    query: DocumentNode | TypedDocumentNode<Data, Variables> | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): PromisifiedSource<OperationResult<Data, Variables>>;\n\n  executeMutation<Data = any, Variables = object>(\n    query: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): Source<OperationResult<Data, Variables>>;\n}\n\nexport const Client: new (opts: ClientOptions) => Client = function Client(\n  this: Client | {},\n  opts: ClientOptions\n) {\n  if (process.env.NODE_ENV !== 'production' && !opts.url) {\n    throw new Error('You are creating an urql-client without a url.');\n  }\n\n  const replays = new Map<number, OperationResult>();\n  const active: Map<number, Source<OperationResult>> = new Map();\n  const queue: Operation[] = [];\n\n  // This subject forms the input of operations; executeOperation may be\n  // called to dispatch a new operation on the subject\n  const { source: operations$, next: nextOperation } = makeSubject<Operation>();\n\n  // We define a queued dispatcher on the subject, which empties the queue when it's\n  // activated to allow `reexecuteOperation` to be trampoline-scheduled\n  let isOperationBatchActive = false;\n  function dispatchOperation(operation?: Operation | void) {\n    isOperationBatchActive = true;\n    if (operation) nextOperation(operation);\n    while ((operation = queue.shift())) nextOperation(operation);\n    isOperationBatchActive = false;\n  }\n\n  /** Defines how result streams are created */\n  const makeResultSource = (operation: Operation) => {\n    let result$ = pipe(\n      results$,\n      filter(\n        (res: OperationResult) =>\n          res.operation.kind === operation.kind &&\n          res.operation.key === operation.key\n      )\n    );\n\n    // Mask typename properties if the option for it is turned on\n    if (client.maskTypename) {\n      result$ = pipe(\n        result$,\n        map(res => ({ ...res, data: maskTypename(res.data) }))\n      );\n    }\n\n    // A mutation is always limited to just a single result and is never shared\n    if (operation.kind === 'mutation') {\n      return pipe(\n        result$,\n        onStart(() => dispatchOperation(operation)),\n        take(1)\n      );\n    }\n\n    const source = pipe(\n      result$,\n      // End the results stream when an active teardown event is sent\n      takeUntil(\n        pipe(\n          operations$,\n          filter(op => op.kind === 'teardown' && op.key === operation.key)\n        )\n      ),\n      switchMap(result => {\n        if (operation.kind !== 'query' || result.stale) {\n          return fromValue(result);\n        }\n\n        return merge([\n          fromValue(result),\n          // Mark a result as stale when a new operation is sent for it\n          pipe(\n            operations$,\n            filter(\n              op =>\n                op.kind === 'query' &&\n                op.key === operation.key &&\n                op.context.requestPolicy !== 'cache-only'\n            ),\n            take(1),\n            map(() => ({ ...result, stale: true }))\n          ),\n        ]);\n      }),\n      onPush(result => {\n        replays.set(operation.key, result);\n      }),\n      onEnd(() => {\n        // Delete the active operation handle\n        replays.delete(operation.key);\n        active.delete(operation.key);\n        // Delete all queued up operations of the same key on end\n        for (let i = queue.length - 1; i >= 0; i--)\n          if (queue[i].key === operation.key) queue.splice(i, 1);\n        // Dispatch a teardown signal for the stopped operation\n        dispatchOperation(\n          makeOperation('teardown', operation, operation.context)\n        );\n      }),\n      share\n    );\n\n    return source;\n  };\n\n  const instance: Client =\n    this instanceof Client ? this : Object.create(Client.prototype);\n  const client: Client = Object.assign(instance, {\n    url: opts.url,\n    fetchOptions: opts.fetchOptions,\n    fetch: opts.fetch,\n    suspense: !!opts.suspense,\n    requestPolicy: opts.requestPolicy || 'cache-first',\n    preferGetMethod: !!opts.preferGetMethod,\n    maskTypename: !!opts.maskTypename,\n\n    operations$,\n\n    reexecuteOperation(operation: Operation) {\n      // Reexecute operation only if any subscribers are still subscribed to the\n      // operation's exchange results\n      if (operation.kind === 'mutation' || active.has(operation.key)) {\n        queue.push(operation);\n        if (!isOperationBatchActive) {\n          Promise.resolve().then(dispatchOperation);\n        }\n      }\n    },\n\n    createOperationContext(opts) {\n      if (!opts) opts = {};\n\n      return {\n        url: client.url,\n        fetchOptions: client.fetchOptions,\n        fetch: client.fetch,\n        preferGetMethod: client.preferGetMethod,\n        ...opts,\n        suspense: opts.suspense || (opts.suspense !== false && client.suspense),\n        requestPolicy: opts.requestPolicy || client.requestPolicy,\n      };\n    },\n\n    createRequestOperation(kind, request, opts) {\n      const requestOperationType = getOperationType(request.query);\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        kind !== 'teardown' &&\n        requestOperationType !== kind\n      ) {\n        throw new Error(\n          `Expected operation of type \"${kind}\" but found \"${requestOperationType}\"`\n        );\n      }\n      return makeOperation(kind, request, client.createOperationContext(opts));\n    },\n\n    executeRequestOperation(operation) {\n      if (operation.kind === 'mutation') {\n        return makeResultSource(operation);\n      }\n\n      return make(observer => {\n        let source = active.get(operation.key);\n\n        if (!source) {\n          active.set(operation.key, (source = makeResultSource(operation)));\n        }\n\n        const isNetworkOperation =\n          operation.context.requestPolicy === 'cache-and-network' ||\n          operation.context.requestPolicy === 'network-only';\n\n        return pipe(\n          source,\n          onStart(() => {\n            const prevReplay = replays.get(operation.key);\n\n            if (operation.kind === 'subscription') {\n              return dispatchOperation(operation);\n            } else if (isNetworkOperation) {\n              dispatchOperation(operation);\n            }\n\n            if (\n              prevReplay != null &&\n              prevReplay === replays.get(operation.key)\n            ) {\n              observer.next(\n                isNetworkOperation ? { ...prevReplay, stale: true } : prevReplay\n              );\n            } else if (!isNetworkOperation) {\n              dispatchOperation(operation);\n            }\n          }),\n          onEnd(observer.complete),\n          subscribe(observer.next)\n        ).unsubscribe;\n      });\n    },\n\n    executeQuery(query, opts) {\n      const operation = client.createRequestOperation('query', query, opts);\n      return client.executeRequestOperation(operation);\n    },\n\n    executeSubscription(query, opts) {\n      const operation = client.createRequestOperation(\n        'subscription',\n        query,\n        opts\n      );\n      return client.executeRequestOperation(operation);\n    },\n\n    executeMutation(query, opts) {\n      const operation = client.createRequestOperation('mutation', query, opts);\n      return client.executeRequestOperation(operation);\n    },\n\n    query(query, variables, context) {\n      if (!context || typeof context.suspense !== 'boolean') {\n        context = { ...context, suspense: false };\n      }\n\n      return withPromise(\n        client.executeQuery(createRequest(query, variables), context)\n      );\n    },\n\n    readQuery(query, variables, context) {\n      let result: OperationResult | null = null;\n\n      pipe(\n        client.query(query, variables, context),\n        subscribe(res => {\n          result = res;\n        })\n      ).unsubscribe();\n\n      return result;\n    },\n\n    subscription(query, variables, context) {\n      return client.executeSubscription(\n        createRequest(query, variables),\n        context\n      );\n    },\n\n    mutation(query, variables, context) {\n      return withPromise(\n        client.executeMutation(createRequest(query, variables), context)\n      );\n    },\n  } as Client);\n\n  let dispatchDebug: ExchangeInput['dispatchDebug'] = noop;\n  if (process.env.NODE_ENV !== 'production') {\n    const { next, source } = makeSubject<DebugEvent>();\n    client.subscribeToDebugTarget = (onEvent: (e: DebugEvent) => void) =>\n      pipe(source, subscribe(onEvent));\n    dispatchDebug = next as ExchangeInput['dispatchDebug'];\n  }\n\n  const exchanges =\n    opts.exchanges !== undefined ? opts.exchanges : defaultExchanges;\n\n  // All exchange are composed into a single one and are called using the constructed client\n  // and the fallback exchange stream\n  const composedExchange = composeExchanges(exchanges);\n\n  // All exchanges receive inputs using which they can forward operations to the next exchange\n  // and receive a stream of results in return, access the client, or dispatch debugging events\n  // All operations then run through the Exchange IOs in a pipeline-like fashion\n  const results$ = share(\n    composedExchange({\n      client,\n      dispatchDebug,\n      forward: fallbackExchange({ dispatchDebug }),\n    })(operations$)\n  );\n\n  // Prevent the `results$` exchange pipeline from being closed by active\n  // cancellations cascading up from components\n  pipe(results$, publish);\n\n  return client;\n} as any;\n\nexport const createClient = (Client as any) as (opts: ClientOptions) => Client;\n", "export const _contextKey = '$$_urql';\nexport const _storeUpdate = new WeakSet<object>();\nexport const _markStoreUpdate =\n  process.env.NODE_ENV !== 'production'\n    ? (value: object) => _storeUpdate.add(value)\n    : () => undefined;\n", "import { Readable, writable } from 'svelte/store';\nimport { DocumentNode } from 'graphql';\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport {\n  OperationContext,\n  CombinedError,\n  createRequest,\n  stringifyVariables,\n} from '@urql/core';\n\nimport { _storeUpdate } from './internal';\n\ntype Updater<T> = (value: T) => T;\n\n/**\n * This Svelte store wraps both a `GraphQLRequest` and an `OperationResult`.\n * It can be used to update the query and read the subsequent result back.\n */\nexport interface OperationStore<Data = any, Vars = any, Result = Data>\n  extends Readable<OperationStore<Data, Vars, Result>> {\n  // Input properties\n  query: DocumentNode | TypedDocumentNode<Data, Vars> | string;\n  variables: Vars | null;\n  context: Partial<OperationContext & { pause: boolean }> | undefined;\n  // Output properties\n  readonly stale: boolean;\n  readonly fetching: boolean;\n  readonly data: Result | undefined;\n  readonly error: CombinedError | undefined;\n  readonly extensions: Record<string, any> | undefined;\n  // Writable properties\n  set(value: Partial<OperationStore<Data, Vars, Result>>): void;\n  update(updater: Updater<Partial<OperationStore<Data, Vars, Result>>>): void;\n  // Imperative methods\n  reexecute(context?: Partial<OperationContext> | undefined): void;\n}\n\nexport function operationStore<Data = any, Vars = object, Result = Data>(\n  query: string | DocumentNode | TypedDocumentNode<Data, Vars>,\n  variables?: Vars | null,\n  context?: Partial<OperationContext & { pause: boolean }>\n): OperationStore<Data, Vars, Result> {\n  const internal = {\n    query,\n    variables: variables || null,\n    context,\n  };\n\n  const state = {\n    stale: false,\n    fetching: false,\n    data: undefined,\n    error: undefined,\n    extensions: undefined,\n  } as OperationStore<Data, Vars, Result>;\n\n  const svelteStore = writable(state);\n  let _internalUpdate = false;\n\n  state.set = function set(value?: Partial<typeof state>) {\n    if (!value || value === state) return;\n\n    _internalUpdate = true;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!_storeUpdate.has(value!)) {\n        for (const key in value) {\n          if (!(key in internal)) {\n            throw new TypeError(\n              'It is not allowed to update result properties on an OperationStore.'\n            );\n          }\n        }\n      }\n    }\n\n    let hasUpdate = false;\n\n    if ('query' in value! || 'variables' in value!) {\n      const prev = createRequest(internal.query, internal.variables);\n      const next = createRequest(\n        value.query || internal.query,\n        value.variables || internal.variables\n      );\n      if (prev.key !== next.key) {\n        hasUpdate = true;\n        internal.query = value.query || internal.query;\n        internal.variables = value.variables || internal.variables || null;\n      }\n    }\n\n    if ('context' in value!) {\n      const prevKey = stringifyVariables(internal.context);\n      const nextKey = stringifyVariables(value.context);\n      if (prevKey !== nextKey) {\n        hasUpdate = true;\n        internal.context = value.context;\n      }\n    }\n\n    for (const key in value) {\n      if (key === 'query' || key === 'variables' || key === 'context') {\n        continue;\n      } else if (key === 'fetching') {\n        (state as any)[key] = !!value[key];\n      } else if (key in state) {\n        state[key] = value[key];\n      }\n\n      hasUpdate = true;\n    }\n\n    (state as any).stale = !!value!.stale;\n\n    _internalUpdate = false;\n    if (hasUpdate) svelteStore.set(state);\n  };\n\n  state.update = function update(fn: Updater<typeof state>): void {\n    state.set(fn(state));\n  };\n\n  state.subscribe = function subscribe(run, invalidate) {\n    return svelteStore.subscribe(run, invalidate);\n  };\n\n  state.reexecute = function (context) {\n    internal.context = { ...(context || internal.context) };\n    svelteStore.set(state);\n  };\n\n  Object.keys(internal).forEach(prop => {\n    Object.defineProperty(state, prop, {\n      configurable: false,\n      get: () => internal[prop],\n      set(value) {\n        internal[prop] = value;\n        if (!_internalUpdate) svelteStore.set(state);\n      },\n    });\n  });\n\n  if (process.env.NODE_ENV !== 'production') {\n    const result = { ...state };\n\n    Object.keys(state).forEach(prop => {\n      Object.defineProperty(result, prop, {\n        configurable: false,\n        get() {\n          return state[prop];\n        },\n        set() {\n          throw new TypeError(\n            'It is not allowed to update result properties on an OperationStore.'\n          );\n        },\n      });\n    });\n\n    Object.keys(internal).forEach(prop => {\n      Object.defineProperty(result, prop, {\n        configurable: false,\n        get: () => internal[prop],\n        set(value) {\n          internal[prop] = value;\n          if (!_internalUpdate) svelteStore.set(state);\n        },\n      });\n    });\n\n    return result;\n  }\n\n  return state;\n}\n", "import { setContext, getContext } from 'svelte';\nimport { Client, ClientOptions } from '@urql/core';\nimport { _contextKey } from './internal';\n\nexport const getClient = (): Client => getContext(_contextKey);\n\nexport const setClient = (client: Client): void => {\n  setContext(_contextKey, client);\n};\n\nexport const initClient = (args: ClientOptions): Client => {\n  const client = new Client(args);\n  setClient(client);\n  return client;\n};\n", "import { onDestroy } from 'svelte';\n\nimport {\n  createRequest,\n  OperationContext,\n  OperationResult,\n  GraphQLRequest,\n  TypedDocumentNode,\n} from '@urql/core';\n\nimport {\n  Source,\n  pipe,\n  map,\n  make,\n  scan,\n  concat,\n  fromValue,\n  switchMap,\n  subscribe,\n  toPromise,\n  take,\n} from 'wonka';\n\nimport { OperationStore, operationStore } from './operationStore';\nimport { getClient } from './context';\nimport { _markStoreUpdate } from './internal';\nimport { DocumentNode } from 'graphql';\n\ninterface SourceRequest<Data = any, Variables = object>\n  extends GraphQLRequest<Data, Variables> {\n  context?: Partial<OperationContext> & {\n    pause?: boolean;\n  };\n}\n\nconst baseState = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n};\n\nfunction toSource<Data, Variables, Result>(\n  store: OperationStore<Data, Variables, Result>\n) {\n  return make<SourceRequest<Data, Variables>>(observer => {\n    let _key: number | void;\n    let _context: object | void = {};\n\n    return store.subscribe(state => {\n      const request = createRequest<Data, Variables>(\n        state.query,\n        state.variables!\n      ) as SourceRequest<Data, Variables>;\n      if (\n        (request.context = state.context) !== _context ||\n        request.key !== _key\n      ) {\n        _key = request.key;\n        _context = state.context;\n        observer.next(request);\n      }\n    });\n  });\n}\n\nexport function query<Data = any, Variables = object>(\n  store: OperationStore<Data, Variables>\n): OperationStore<Data, Variables> {\n  const client = getClient();\n  const subscription = pipe(\n    toSource(store),\n    switchMap(request => {\n      if (request.context && request.context.pause) {\n        return fromValue({ fetching: false, stale: false });\n      }\n\n      return concat([\n        fromValue({ fetching: true, stale: false }),\n        pipe(\n          client.executeQuery<Data, Variables>(request, request.context!),\n          map(result => ({\n            fetching: false,\n            ...result,\n            stale: !!result.stale,\n          }))\n        ),\n        fromValue({ fetching: false, stale: false }),\n      ]);\n    }),\n    scan(\n      (result: Partial<OperationResult<Data, Variables>>, partial) => ({\n        ...result,\n        ...partial,\n      }),\n      baseState\n    ),\n    subscribe(update => {\n      _markStoreUpdate(update);\n      store.set(update as OperationStore);\n    })\n  );\n\n  onDestroy(subscription.unsubscribe);\n  return store;\n}\n\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\nexport function subscription<Data = any, Result = Data, Variables = object>(\n  store: OperationStore<Data, Variables, any>,\n  handler?: SubscriptionHandler<Data, Result>\n): OperationStore<Data, Variables, Result> {\n  const client = getClient();\n  const subscription = pipe(\n    toSource(store),\n    switchMap(\n      (request): Source<Partial<OperationStore>> => {\n        if (request.context && request.context.pause) {\n          return fromValue({ fetching: false });\n        }\n\n        return concat<Partial<OperationStore>>([\n          fromValue({ fetching: true }),\n          client.executeSubscription(request, store.context),\n          fromValue({ fetching: false }),\n        ]);\n      }\n    ),\n    scan(\n      (result: Partial<OperationResult<Result, Variables>>, partial: any) => {\n        const data =\n          partial.data !== undefined\n            ? typeof handler === 'function'\n              ? handler(result.data, partial.data)\n              : partial.data\n            : result.data;\n        return { ...result, ...partial, data, stale: false };\n      },\n      baseState\n    ),\n    subscribe(update => {\n      _markStoreUpdate(update);\n      store.set(update);\n    })\n  );\n\n  onDestroy(subscription.unsubscribe);\n  return store;\n}\n\nexport type ExecuteMutation<Data = any, Variables = object> = (\n  variables?: Variables,\n  context?: Partial<OperationContext>\n) => Promise<OperationStore<Data, Variables>>;\n\ninterface GraphQLRequestInput<Data = any, Variables = object> {\n  key?: number;\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string;\n  variables?: Variables;\n}\n\nexport function mutation<Data = any, Variables = object>(\n  input: GraphQLRequestInput<Data, Variables> | OperationStore<Data, Variables>\n): ExecuteMutation<Data, Variables> {\n  const client = getClient();\n\n  const store =\n    typeof (input as any).subscribe !== 'function'\n      ? operationStore<Data, Variables>(input.query, input.variables)\n      : (input as OperationStore<Data, Variables>);\n\n  return (vars, context) => {\n    const update = {\n      fetching: true,\n      variables: vars || store.variables,\n      context: context || store.context,\n    };\n\n    _markStoreUpdate(update);\n    store.set(update);\n    return pipe(\n      client.executeMutation(\n        createRequest(store.query, store.variables || {}),\n        store.context\n      ),\n      take(1),\n      toPromise\n    ).then(result => {\n      const update = { fetching: false, ...result };\n      _markStoreUpdate(update);\n      store.set(update);\n      return store;\n    });\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
