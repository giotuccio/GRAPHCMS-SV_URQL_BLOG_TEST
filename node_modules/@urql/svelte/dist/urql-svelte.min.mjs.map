{"version":3,"file":"urql-svelte.min.mjs","sources":["../src/operationStore.ts","../src/context.ts","../src/internal.ts","../src/operations.ts"],"sourcesContent":["import { Readable, writable } from 'svelte/store';\nimport { DocumentNode } from 'graphql';\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport {\n  OperationContext,\n  CombinedError,\n  createRequest,\n  stringifyVariables,\n} from '@urql/core';\n\nimport { _storeUpdate } from './internal';\n\ntype Updater<T> = (value: T) => T;\n\n/**\n * This Svelte store wraps both a `GraphQLRequest` and an `OperationResult`.\n * It can be used to update the query and read the subsequent result back.\n */\nexport interface OperationStore<Data = any, Vars = any, Result = Data>\n  extends Readable<OperationStore<Data, Vars, Result>> {\n  // Input properties\n  query: DocumentNode | TypedDocumentNode<Data, Vars> | string;\n  variables: Vars | null;\n  context: Partial<OperationContext & { pause: boolean }> | undefined;\n  // Output properties\n  readonly stale: boolean;\n  readonly fetching: boolean;\n  readonly data: Result | undefined;\n  readonly error: CombinedError | undefined;\n  readonly extensions: Record<string, any> | undefined;\n  // Writable properties\n  set(value: Partial<OperationStore<Data, Vars, Result>>): void;\n  update(updater: Updater<Partial<OperationStore<Data, Vars, Result>>>): void;\n  // Imperative methods\n  reexecute(context?: Partial<OperationContext> | undefined): void;\n}\n\nexport function operationStore<Data = any, Vars = object, Result = Data>(\n  query: string | DocumentNode | TypedDocumentNode<Data, Vars>,\n  variables?: Vars | null,\n  context?: Partial<OperationContext & { pause: boolean }>\n): OperationStore<Data, Vars, Result> {\n  const internal = {\n    query,\n    variables: variables || null,\n    context,\n  };\n\n  const state = {\n    stale: false,\n    fetching: false,\n    data: undefined,\n    error: undefined,\n    extensions: undefined,\n  } as OperationStore<Data, Vars, Result>;\n\n  const svelteStore = writable(state);\n  let _internalUpdate = false;\n\n  state.set = function set(value?: Partial<typeof state>) {\n    if (!value || value === state) return;\n\n    _internalUpdate = true;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!_storeUpdate.has(value!)) {\n        for (const key in value) {\n          if (!(key in internal)) {\n            throw new TypeError(\n              'It is not allowed to update result properties on an OperationStore.'\n            );\n          }\n        }\n      }\n    }\n\n    let hasUpdate = false;\n\n    if ('query' in value! || 'variables' in value!) {\n      const prev = createRequest(internal.query, internal.variables);\n      const next = createRequest(\n        value.query || internal.query,\n        value.variables || internal.variables\n      );\n      if (prev.key !== next.key) {\n        hasUpdate = true;\n        internal.query = value.query || internal.query;\n        internal.variables = value.variables || internal.variables || null;\n      }\n    }\n\n    if ('context' in value!) {\n      const prevKey = stringifyVariables(internal.context);\n      const nextKey = stringifyVariables(value.context);\n      if (prevKey !== nextKey) {\n        hasUpdate = true;\n        internal.context = value.context;\n      }\n    }\n\n    for (const key in value) {\n      if (key === 'query' || key === 'variables' || key === 'context') {\n        continue;\n      } else if (key === 'fetching') {\n        (state as any)[key] = !!value[key];\n      } else if (key in state) {\n        state[key] = value[key];\n      }\n\n      hasUpdate = true;\n    }\n\n    (state as any).stale = !!value!.stale;\n\n    _internalUpdate = false;\n    if (hasUpdate) svelteStore.set(state);\n  };\n\n  state.update = function update(fn: Updater<typeof state>): void {\n    state.set(fn(state));\n  };\n\n  state.subscribe = function subscribe(run, invalidate) {\n    return svelteStore.subscribe(run, invalidate);\n  };\n\n  state.reexecute = function (context) {\n    internal.context = { ...(context || internal.context) };\n    svelteStore.set(state);\n  };\n\n  Object.keys(internal).forEach(prop => {\n    Object.defineProperty(state, prop, {\n      configurable: false,\n      get: () => internal[prop],\n      set(value) {\n        internal[prop] = value;\n        if (!_internalUpdate) svelteStore.set(state);\n      },\n    });\n  });\n\n  if (process.env.NODE_ENV !== 'production') {\n    const result = { ...state };\n\n    Object.keys(state).forEach(prop => {\n      Object.defineProperty(result, prop, {\n        configurable: false,\n        get() {\n          return state[prop];\n        },\n        set() {\n          throw new TypeError(\n            'It is not allowed to update result properties on an OperationStore.'\n          );\n        },\n      });\n    });\n\n    Object.keys(internal).forEach(prop => {\n      Object.defineProperty(result, prop, {\n        configurable: false,\n        get: () => internal[prop],\n        set(value) {\n          internal[prop] = value;\n          if (!_internalUpdate) svelteStore.set(state);\n        },\n      });\n    });\n\n    return result;\n  }\n\n  return state;\n}\n","import { setContext, getContext } from 'svelte';\nimport { Client, ClientOptions } from '@urql/core';\nimport { _contextKey } from './internal';\n\nexport const getClient = (): Client => getContext(_contextKey);\n\nexport const setClient = (client: Client): void => {\n  setContext(_contextKey, client);\n};\n\nexport const initClient = (args: ClientOptions): Client => {\n  const client = new Client(args);\n  setClient(client);\n  return client;\n};\n","export const _contextKey = '$$_urql';\nexport const _storeUpdate = new WeakSet<object>();\nexport const _markStoreUpdate =\n  process.env.NODE_ENV !== 'production'\n    ? (value: object) => _storeUpdate.add(value)\n    : () => undefined;\n","import { onDestroy } from 'svelte';\n\nimport {\n  createRequest,\n  OperationContext,\n  OperationResult,\n  GraphQLRequest,\n  TypedDocumentNode,\n} from '@urql/core';\n\nimport {\n  Source,\n  pipe,\n  map,\n  make,\n  scan,\n  concat,\n  fromValue,\n  switchMap,\n  subscribe,\n  toPromise,\n  take,\n} from 'wonka';\n\nimport { OperationStore, operationStore } from './operationStore';\nimport { getClient } from './context';\nimport { _markStoreUpdate } from './internal';\nimport { DocumentNode } from 'graphql';\n\ninterface SourceRequest<Data = any, Variables = object>\n  extends GraphQLRequest<Data, Variables> {\n  context?: Partial<OperationContext> & {\n    pause?: boolean;\n  };\n}\n\nconst baseState = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n};\n\nfunction toSource<Data, Variables, Result>(\n  store: OperationStore<Data, Variables, Result>\n) {\n  return make<SourceRequest<Data, Variables>>(observer => {\n    let _key: number | void;\n    let _context: object | void = {};\n\n    return store.subscribe(state => {\n      const request = createRequest<Data, Variables>(\n        state.query,\n        state.variables!\n      ) as SourceRequest<Data, Variables>;\n      if (\n        (request.context = state.context) !== _context ||\n        request.key !== _key\n      ) {\n        _key = request.key;\n        _context = state.context;\n        observer.next(request);\n      }\n    });\n  });\n}\n\nexport function query<Data = any, Variables = object>(\n  store: OperationStore<Data, Variables>\n): OperationStore<Data, Variables> {\n  const client = getClient();\n  const subscription = pipe(\n    toSource(store),\n    switchMap(request => {\n      if (request.context && request.context.pause) {\n        return fromValue({ fetching: false, stale: false });\n      }\n\n      return concat([\n        fromValue({ fetching: true, stale: false }),\n        pipe(\n          client.executeQuery<Data, Variables>(request, request.context!),\n          map(result => ({\n            fetching: false,\n            ...result,\n            stale: !!result.stale,\n          }))\n        ),\n        fromValue({ fetching: false, stale: false }),\n      ]);\n    }),\n    scan(\n      (result: Partial<OperationResult<Data, Variables>>, partial) => ({\n        ...result,\n        ...partial,\n      }),\n      baseState\n    ),\n    subscribe(update => {\n      _markStoreUpdate(update);\n      store.set(update as OperationStore);\n    })\n  );\n\n  onDestroy(subscription.unsubscribe);\n  return store;\n}\n\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\nexport function subscription<Data = any, Result = Data, Variables = object>(\n  store: OperationStore<Data, Variables, any>,\n  handler?: SubscriptionHandler<Data, Result>\n): OperationStore<Data, Variables, Result> {\n  const client = getClient();\n  const subscription = pipe(\n    toSource(store),\n    switchMap(\n      (request): Source<Partial<OperationStore>> => {\n        if (request.context && request.context.pause) {\n          return fromValue({ fetching: false });\n        }\n\n        return concat<Partial<OperationStore>>([\n          fromValue({ fetching: true }),\n          client.executeSubscription(request, store.context),\n          fromValue({ fetching: false }),\n        ]);\n      }\n    ),\n    scan(\n      (result: Partial<OperationResult<Result, Variables>>, partial: any) => {\n        const data =\n          partial.data !== undefined\n            ? typeof handler === 'function'\n              ? handler(result.data, partial.data)\n              : partial.data\n            : result.data;\n        return { ...result, ...partial, data, stale: false };\n      },\n      baseState\n    ),\n    subscribe(update => {\n      _markStoreUpdate(update);\n      store.set(update);\n    })\n  );\n\n  onDestroy(subscription.unsubscribe);\n  return store;\n}\n\nexport type ExecuteMutation<Data = any, Variables = object> = (\n  variables?: Variables,\n  context?: Partial<OperationContext>\n) => Promise<OperationStore<Data, Variables>>;\n\ninterface GraphQLRequestInput<Data = any, Variables = object> {\n  key?: number;\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string;\n  variables?: Variables;\n}\n\nexport function mutation<Data = any, Variables = object>(\n  input: GraphQLRequestInput<Data, Variables> | OperationStore<Data, Variables>\n): ExecuteMutation<Data, Variables> {\n  const client = getClient();\n\n  const store =\n    typeof (input as any).subscribe !== 'function'\n      ? operationStore<Data, Variables>(input.query, input.variables)\n      : (input as OperationStore<Data, Variables>);\n\n  return (vars, context) => {\n    const update = {\n      fetching: true,\n      variables: vars || store.variables,\n      context: context || store.context,\n    };\n\n    _markStoreUpdate(update);\n    store.set(update);\n    return pipe(\n      client.executeMutation(\n        createRequest(store.query, store.variables || {}),\n        store.context\n      ),\n      take(1),\n      toPromise\n    ).then(result => {\n      const update = { fetching: false, ...result };\n      _markStoreUpdate(update);\n      store.set(update);\n      return store;\n    });\n  };\n}\n"],"names":["data","error","extensions","hasUpdate","prev","value","internal","key","state","setClient","initClient","args","fetching","process","let","context","request","stale","store","subscription","update","scan","partial","fromValue","variables"],"mappings":"mmBAkDc,CACVA,SACAC,YACAC,uGAwBIC,mEAMEC,IAAJC,2DAGEC,0NAkBSC,EACTC,EAAMD,0KAsBMC,0JAOVH,+CClIoD,oBAEjDI,ECNc,oBDUdC,OCVc,UDWCC,GAG3B,6BEuBCC,kBDlCAC,QCqCAb,OACAE,UAAU,uDAQRY,4CAQaC,8PAmBTC,qEAQY,aAERC,gEAAAA,GAbCC,2EA0CCC,iBA8BRD,SAAKC,+BAXDC,eAKKC,gDAvBKC,0EAuBLD,sEAtBHE,4GA4DNC,kBACAT,EAASA,iJAUJG,+FAKLA,sBACA"}